import "./chunk-XCTHCOCC.js";
import {
  structureLocaleNamespace,
  useDocumentPane,
  usePaneRouter
} from "./chunk-HAZKDGXQ.js";
import "./chunk-MZ5EFMZT.js";
import {
  ArrayOfObjectsItem,
  DEFAULT_STUDIO_CLIENT_OPTIONS,
  InsufficientPermissionsMessage,
  MemberItemError,
  Mutation,
  PatchEvent,
  Preview$1,
  RouterContext,
  TextWithTone,
  catchError,
  defineDocumentFieldAction,
  defineField,
  defineLocaleResourceBundle,
  definePlugin,
  defineType,
  distinctUntilChanged,
  extractWithPath,
  insert$1,
  isDocumentSchemaType,
  isObjectInputProps,
  isObjectSchemaType,
  isSanityDocument,
  pathToString$1,
  require_get,
  require_react_fast_compare,
  set,
  setIfMissing,
  unset,
  useClient,
  useCurrentUser,
  useDocumentOperation,
  useDocumentPairPermissions,
  useDocumentStore,
  useEditState,
  useFormValue,
  useRouter,
  useSchema,
  useTranslation2 as useTranslation,
  useValidationStatus,
  useWorkspace,
  v4_default
} from "./chunk-GWXYEOR2.js";
import {
  Badge,
  Box,
  Button,
  Card,
  Code,
  Dialog,
  Flex,
  Grid,
  Inline,
  Label,
  Menu,
  MenuButton,
  MenuItem,
  Popover,
  Spinner,
  Stack,
  Text,
  TextInput,
  Tooltip,
  dt,
  lt,
  useClickOutside,
  useToast
} from "./chunk-DLVT6UAM.js";
import "./chunk-ORQM2G6B.js";
import "./chunk-LD3VNU3R.js";
import "./chunk-B6QUAMBD.js";
import "./chunk-DG3JXI3H.js";
import {
  AddIcon,
  CheckmarkCircleIcon,
  CheckmarkIcon,
  CircleIcon,
  CogIcon,
  CopyIcon,
  EditIcon,
  EyeClosedIcon,
  EyeOpenIcon,
  InfoOutlineIcon,
  RemoveCircleIcon,
  SplitVerticalIcon,
  TranslateIcon,
  TrashIcon
} from "./chunk-7WLEJDEH.js";
import {
  require_jsx_runtime
} from "./chunk-4UOXVWM6.js";
import {
  require_react
} from "./chunk-U3RAP3IQ.js";
import {
  __commonJS,
  __toESM
} from "./chunk-5IKWDFCZ.js";

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal2(a2, b) {
      if (a2 === b) return true;
      if (a2 && b && typeof a2 == "object" && typeof b == "object") {
        if (a2.constructor !== b.constructor) return false;
        var length, i2, keys;
        if (Array.isArray(a2)) {
          length = a2.length;
          if (length != b.length) return false;
          for (i2 = length; i2-- !== 0; )
            if (!equal2(a2[i2], b[i2])) return false;
          return true;
        }
        if (a2.constructor === RegExp) return a2.source === b.source && a2.flags === b.flags;
        if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b.valueOf();
        if (a2.toString !== Object.prototype.toString) return a2.toString() === b.toString();
        keys = Object.keys(a2);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i2 = length; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i2])) return false;
        for (i2 = length; i2-- !== 0; ) {
          var key = keys[i2];
          if (!equal2(a2[key], b[key])) return false;
        }
        return true;
      }
      return a2 !== a2 && b !== b;
    };
  }
});

// node_modules/@sanity/document-internationalization/dist/index.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);

// node_modules/sanity-plugin-utils/lib/index.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());
var import_react_fast_compare = __toESM(require_react_fast_compare());
var __defProp$3 = Object.defineProperty;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a2, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$3.call(b, prop) && __defNormalProp$3(a2, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b))
      __propIsEnum$3.call(b, prop) && __defNormalProp$3(a2, prop, b[prop]);
  return a2;
};
var DEFAULT_PROPS = {
  tone: "primary"
};
function Feedback(props) {
  const { title, description, icon, tone, children } = __spreadValues$3(__spreadValues$3({}, DEFAULT_PROPS), props);
  return (0, import_jsx_runtime.jsx)(Card, { tone, padding: 4, radius: 3, border: true, children: (0, import_jsx_runtime.jsxs)(Flex, { children: [
    icon ? "display icon" : null,
    children || (0, import_jsx_runtime.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime.jsxs)(Stack, { space: 4, children: [
      title ? (0, import_jsx_runtime.jsx)(Text, { weight: "semibold", children: title }) : null,
      description ? (0, import_jsx_runtime.jsx)(Text, { size: 2, children: description }) : null
    ] }) })
  ] }) });
}
var __defProp$2 = Object.defineProperty;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a2, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$2.call(b, prop) && __defNormalProp$2(a2, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b))
      __propIsEnum$2.call(b, prop) && __defNormalProp$2(a2, prop, b[prop]);
  return a2;
};
var TableWrapper = (props = {}) => (0, import_jsx_runtime.jsx)(Card, __spreadValues$2({ as: "table" }, props));
var StyledTable = dt(TableWrapper)(
  () => lt`
    display: table;
    width: 100%;
    border-collapse: collapse;

    &:not([hidden]) {
      display: table;
      border-collapse: collapse;
    }
  `
);
var RowWrapper = (props = {}) => (0, import_jsx_runtime.jsx)(Card, __spreadValues$2({ as: "tr" }, props));
var StyledRow = dt(RowWrapper)(
  () => lt`
    display: table-row;

    &:not([hidden]) {
      display: table-row;
    }
  `
);
var CellWrapper = (props = {}) => (0, import_jsx_runtime.jsx)(Card, __spreadValues$2({ as: "td" }, props));
var StyledCell = dt(CellWrapper)(
  () => lt`
    display: table-cell;

    &:not([hidden]) {
      display: table-cell;
    }
  `
);
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}
var builder = {};
var urlForImage = {};
var parseAssetId = {};
var hasRequiredParseAssetId;
function requireParseAssetId() {
  if (hasRequiredParseAssetId) return parseAssetId;
  hasRequiredParseAssetId = 1, Object.defineProperty(parseAssetId, "__esModule", { value: true });
  var example = "image-Tb9Ew8CXIwaY6R1kjMvI0uRR-2000x3000-jpg";
  function parseAssetId$1(ref) {
    var _a = ref.split("-"), id = _a[1], dimensionString = _a[2], format = _a[3];
    if (!id || !dimensionString || !format)
      throw new Error("Malformed asset _ref '".concat(ref, `'. Expected an id like "`).concat(example, '".'));
    var _b = dimensionString.split("x"), imgWidthStr = _b[0], imgHeightStr = _b[1], width = +imgWidthStr, height = +imgHeightStr, isValidAssetId = isFinite(width) && isFinite(height);
    if (!isValidAssetId)
      throw new Error("Malformed asset _ref '".concat(ref, `'. Expected an id like "`).concat(example, '".'));
    return { id, width, height, format };
  }
  return parseAssetId.default = parseAssetId$1, parseAssetId;
}
var parseSource = {};
var hasRequiredParseSource;
function requireParseSource() {
  if (hasRequiredParseSource) return parseSource;
  hasRequiredParseSource = 1;
  var __assign = parseSource && parseSource.__assign || function() {
    return __assign = Object.assign || function(t2) {
      for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s2 = arguments[i2];
        for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && (t2[p] = s2[p]);
      }
      return t2;
    }, __assign.apply(this, arguments);
  };
  Object.defineProperty(parseSource, "__esModule", { value: true });
  var isRef = function(src) {
    var source = src;
    return source ? typeof source._ref == "string" : false;
  }, isAsset = function(src) {
    var source = src;
    return source ? typeof source._id == "string" : false;
  }, isAssetStub = function(src) {
    var source = src;
    return source && source.asset ? typeof source.asset.url == "string" : false;
  };
  function parseSource$1(source) {
    if (!source)
      return null;
    var image;
    if (typeof source == "string" && isUrl(source))
      image = {
        asset: { _ref: urlToId(source) }
      };
    else if (typeof source == "string")
      image = {
        asset: { _ref: source }
      };
    else if (isRef(source))
      image = {
        asset: source
      };
    else if (isAsset(source))
      image = {
        asset: {
          _ref: source._id || ""
        }
      };
    else if (isAssetStub(source))
      image = {
        asset: {
          _ref: urlToId(source.asset.url)
        }
      };
    else if (typeof source.asset == "object")
      image = __assign({}, source);
    else
      return null;
    var img = source;
    return img.crop && (image.crop = img.crop), img.hotspot && (image.hotspot = img.hotspot), applyDefaults(image);
  }
  parseSource.default = parseSource$1;
  function isUrl(url) {
    return /^https?:\/\//.test("".concat(url));
  }
  function urlToId(url) {
    var parts = url.split("/").slice(-1);
    return "image-".concat(parts[0]).replace(/\.([a-z]+)$/, "-$1");
  }
  function applyDefaults(image) {
    if (image.crop && image.hotspot)
      return image;
    var result = __assign({}, image);
    return result.crop || (result.crop = {
      left: 0,
      top: 0,
      bottom: 0,
      right: 0
    }), result.hotspot || (result.hotspot = {
      x: 0.5,
      y: 0.5,
      height: 1,
      width: 1
    }), result;
  }
  return parseSource;
}
var hasRequiredUrlForImage;
function requireUrlForImage() {
  return hasRequiredUrlForImage || (hasRequiredUrlForImage = 1, function(exports) {
    var __assign = urlForImage && urlForImage.__assign || function() {
      return __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && (t2[p] = s2[p]);
        }
        return t2;
      }, __assign.apply(this, arguments);
    }, __importDefault = urlForImage && urlForImage.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true }), exports.parseSource = exports.SPEC_NAME_TO_URL_NAME_MAPPINGS = void 0;
    var parseAssetId_1 = __importDefault(requireParseAssetId()), parseSource_1 = __importDefault(requireParseSource());
    exports.parseSource = parseSource_1.default, exports.SPEC_NAME_TO_URL_NAME_MAPPINGS = [
      ["width", "w"],
      ["height", "h"],
      ["format", "fm"],
      ["download", "dl"],
      ["blur", "blur"],
      ["sharpen", "sharp"],
      ["invert", "invert"],
      ["orientation", "or"],
      ["minHeight", "min-h"],
      ["maxHeight", "max-h"],
      ["minWidth", "min-w"],
      ["maxWidth", "max-w"],
      ["quality", "q"],
      ["fit", "fit"],
      ["crop", "crop"],
      ["saturation", "sat"],
      ["auto", "auto"],
      ["dpr", "dpr"],
      ["pad", "pad"]
    ];
    function urlForImage$1(options) {
      var spec = __assign({}, options || {}), source = spec.source;
      delete spec.source;
      var image = (0, parseSource_1.default)(source);
      if (!image)
        throw new Error("Unable to resolve image URL from source (".concat(JSON.stringify(source), ")"));
      var id = image.asset._ref || image.asset._id || "", asset = (0, parseAssetId_1.default)(id), cropLeft = Math.round(image.crop.left * asset.width), cropTop = Math.round(image.crop.top * asset.height), crop = {
        left: cropLeft,
        top: cropTop,
        width: Math.round(asset.width - image.crop.right * asset.width - cropLeft),
        height: Math.round(asset.height - image.crop.bottom * asset.height - cropTop)
      }, hotSpotVerticalRadius = image.hotspot.height * asset.height / 2, hotSpotHorizontalRadius = image.hotspot.width * asset.width / 2, hotSpotCenterX = image.hotspot.x * asset.width, hotSpotCenterY = image.hotspot.y * asset.height, hotspot = {
        left: hotSpotCenterX - hotSpotHorizontalRadius,
        top: hotSpotCenterY - hotSpotVerticalRadius,
        right: hotSpotCenterX + hotSpotHorizontalRadius,
        bottom: hotSpotCenterY + hotSpotVerticalRadius
      };
      return spec.rect || spec.focalPoint || spec.ignoreImageParams || spec.crop || (spec = __assign(__assign({}, spec), fit({ crop, hotspot }, spec))), specToImageUrl(__assign(__assign({}, spec), { asset }));
    }
    exports.default = urlForImage$1;
    function specToImageUrl(spec) {
      var cdnUrl = (spec.baseUrl || "https://cdn.sanity.io").replace(/\/+$/, ""), filename = "".concat(spec.asset.id, "-").concat(spec.asset.width, "x").concat(spec.asset.height, ".").concat(spec.asset.format), baseUrl = "".concat(cdnUrl, "/images/").concat(spec.projectId, "/").concat(spec.dataset, "/").concat(filename), params = [];
      if (spec.rect) {
        var _a = spec.rect, left = _a.left, top_1 = _a.top, width = _a.width, height = _a.height, isEffectiveCrop = left !== 0 || top_1 !== 0 || height !== spec.asset.height || width !== spec.asset.width;
        isEffectiveCrop && params.push("rect=".concat(left, ",").concat(top_1, ",").concat(width, ",").concat(height));
      }
      spec.bg && params.push("bg=".concat(spec.bg)), spec.focalPoint && (params.push("fp-x=".concat(spec.focalPoint.x)), params.push("fp-y=".concat(spec.focalPoint.y)));
      var flip = [spec.flipHorizontal && "h", spec.flipVertical && "v"].filter(Boolean).join("");
      return flip && params.push("flip=".concat(flip)), exports.SPEC_NAME_TO_URL_NAME_MAPPINGS.forEach(function(mapping) {
        var specName = mapping[0], param = mapping[1];
        typeof spec[specName] < "u" ? params.push("".concat(param, "=").concat(encodeURIComponent(spec[specName]))) : typeof spec[param] < "u" && params.push("".concat(param, "=").concat(encodeURIComponent(spec[param])));
      }), params.length === 0 ? baseUrl : "".concat(baseUrl, "?").concat(params.join("&"));
    }
    function fit(source, spec) {
      var cropRect, imgWidth = spec.width, imgHeight = spec.height;
      if (!(imgWidth && imgHeight))
        return { width: imgWidth, height: imgHeight, rect: source.crop };
      var crop = source.crop, hotspot = source.hotspot, desiredAspectRatio = imgWidth / imgHeight, cropAspectRatio = crop.width / crop.height;
      if (cropAspectRatio > desiredAspectRatio) {
        var height = Math.round(crop.height), width = Math.round(height * desiredAspectRatio), top_2 = Math.max(0, Math.round(crop.top)), hotspotXCenter = Math.round((hotspot.right - hotspot.left) / 2 + hotspot.left), left = Math.max(0, Math.round(hotspotXCenter - width / 2));
        left < crop.left ? left = crop.left : left + width > crop.left + crop.width && (left = crop.left + crop.width - width), cropRect = { left, top: top_2, width, height };
      } else {
        var width = crop.width, height = Math.round(width / desiredAspectRatio), left = Math.max(0, Math.round(crop.left)), hotspotYCenter = Math.round((hotspot.bottom - hotspot.top) / 2 + hotspot.top), top_3 = Math.max(0, Math.round(hotspotYCenter - height / 2));
        top_3 < crop.top ? top_3 = crop.top : top_3 + height > crop.top + crop.height && (top_3 = crop.top + crop.height - height), cropRect = { left, top: top_3, width, height };
      }
      return {
        width: imgWidth,
        height: imgHeight,
        rect: cropRect
      };
    }
  }(urlForImage)), urlForImage;
}
var hasRequiredBuilder;
function requireBuilder() {
  if (hasRequiredBuilder) return builder;
  hasRequiredBuilder = 1;
  var __assign = builder && builder.__assign || function() {
    return __assign = Object.assign || function(t2) {
      for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s2 = arguments[i2];
        for (var p in s2) Object.prototype.hasOwnProperty.call(s2, p) && (t2[p] = s2[p]);
      }
      return t2;
    }, __assign.apply(this, arguments);
  }, __createBinding = builder && builder.__createBinding || (Object.create ? function(o2, m, k2, k22) {
    k22 === void 0 && (k22 = k2), Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m[k2];
    } });
  } : function(o2, m, k2, k22) {
    k22 === void 0 && (k22 = k2), o2[k22] = m[k2];
  }), __setModuleDefault = builder && builder.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2.default = v;
  }), __importStar = builder && builder.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k2 in mod) k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2) && __createBinding(result, mod, k2);
    return __setModuleDefault(result, mod), result;
  };
  Object.defineProperty(builder, "__esModule", { value: true }), builder.ImageUrlBuilder = void 0;
  var urlForImage_1 = __importStar(requireUrlForImage()), validFits = ["clip", "crop", "fill", "fillmax", "max", "scale", "min"], validCrops = ["top", "bottom", "left", "right", "center", "focalpoint", "entropy"], validAutoModes = ["format"];
  function isSanityModernClientLike(client) {
    return client && "config" in client ? typeof client.config == "function" : false;
  }
  function isSanityClientLike(client) {
    return client && "clientConfig" in client ? typeof client.clientConfig == "object" : false;
  }
  function rewriteSpecName(key) {
    for (var specs = urlForImage_1.SPEC_NAME_TO_URL_NAME_MAPPINGS, _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {
      var entry = specs_1[_i], specName = entry[0], param = entry[1];
      if (key === specName || key === param)
        return specName;
    }
    return key;
  }
  function urlBuilder(options) {
    if (isSanityModernClientLike(options)) {
      var _a = options.config(), apiUrl = _a.apiHost, projectId = _a.projectId, dataset = _a.dataset, apiHost = apiUrl || "https://api.sanity.io";
      return new ImageUrlBuilder(null, {
        baseUrl: apiHost.replace(/^https:\/\/api\./, "https://cdn."),
        projectId,
        dataset
      });
    }
    var client = options;
    if (isSanityClientLike(client)) {
      var _b = client.clientConfig, apiUrl = _b.apiHost, projectId = _b.projectId, dataset = _b.dataset, apiHost = apiUrl || "https://api.sanity.io";
      return new ImageUrlBuilder(null, {
        baseUrl: apiHost.replace(/^https:\/\/api\./, "https://cdn."),
        projectId,
        dataset
      });
    }
    return new ImageUrlBuilder(null, options);
  }
  builder.default = urlBuilder;
  var ImageUrlBuilder = (
    /** @class */
    function() {
      function ImageUrlBuilder2(parent, options) {
        this.options = parent ? __assign(__assign({}, parent.options || {}), options || {}) : __assign({}, options || {});
      }
      return ImageUrlBuilder2.prototype.withOptions = function(options) {
        var baseUrl = options.baseUrl || this.options.baseUrl, newOptions = { baseUrl };
        for (var key in options)
          if (options.hasOwnProperty(key)) {
            var specKey = rewriteSpecName(key);
            newOptions[specKey] = options[key];
          }
        return new ImageUrlBuilder2(this, __assign({ baseUrl }, newOptions));
      }, ImageUrlBuilder2.prototype.image = function(source) {
        return this.withOptions({ source });
      }, ImageUrlBuilder2.prototype.dataset = function(dataset) {
        return this.withOptions({ dataset });
      }, ImageUrlBuilder2.prototype.projectId = function(projectId) {
        return this.withOptions({ projectId });
      }, ImageUrlBuilder2.prototype.bg = function(bg) {
        return this.withOptions({ bg });
      }, ImageUrlBuilder2.prototype.dpr = function(dpr) {
        return this.withOptions(dpr && dpr !== 1 ? { dpr } : {});
      }, ImageUrlBuilder2.prototype.width = function(width) {
        return this.withOptions({ width });
      }, ImageUrlBuilder2.prototype.height = function(height) {
        return this.withOptions({ height });
      }, ImageUrlBuilder2.prototype.focalPoint = function(x, y) {
        return this.withOptions({ focalPoint: { x, y } });
      }, ImageUrlBuilder2.prototype.maxWidth = function(maxWidth) {
        return this.withOptions({ maxWidth });
      }, ImageUrlBuilder2.prototype.minWidth = function(minWidth) {
        return this.withOptions({ minWidth });
      }, ImageUrlBuilder2.prototype.maxHeight = function(maxHeight) {
        return this.withOptions({ maxHeight });
      }, ImageUrlBuilder2.prototype.minHeight = function(minHeight) {
        return this.withOptions({ minHeight });
      }, ImageUrlBuilder2.prototype.size = function(width, height) {
        return this.withOptions({ width, height });
      }, ImageUrlBuilder2.prototype.blur = function(blur) {
        return this.withOptions({ blur });
      }, ImageUrlBuilder2.prototype.sharpen = function(sharpen) {
        return this.withOptions({ sharpen });
      }, ImageUrlBuilder2.prototype.rect = function(left, top, width, height) {
        return this.withOptions({ rect: { left, top, width, height } });
      }, ImageUrlBuilder2.prototype.format = function(format) {
        return this.withOptions({ format });
      }, ImageUrlBuilder2.prototype.invert = function(invert) {
        return this.withOptions({ invert });
      }, ImageUrlBuilder2.prototype.orientation = function(orientation) {
        return this.withOptions({ orientation });
      }, ImageUrlBuilder2.prototype.quality = function(quality) {
        return this.withOptions({ quality });
      }, ImageUrlBuilder2.prototype.forceDownload = function(download) {
        return this.withOptions({ download });
      }, ImageUrlBuilder2.prototype.flipHorizontal = function() {
        return this.withOptions({ flipHorizontal: true });
      }, ImageUrlBuilder2.prototype.flipVertical = function() {
        return this.withOptions({ flipVertical: true });
      }, ImageUrlBuilder2.prototype.ignoreImageParams = function() {
        return this.withOptions({ ignoreImageParams: true });
      }, ImageUrlBuilder2.prototype.fit = function(value) {
        if (validFits.indexOf(value) === -1)
          throw new Error('Invalid fit mode "'.concat(value, '"'));
        return this.withOptions({ fit: value });
      }, ImageUrlBuilder2.prototype.crop = function(value) {
        if (validCrops.indexOf(value) === -1)
          throw new Error('Invalid crop mode "'.concat(value, '"'));
        return this.withOptions({ crop: value });
      }, ImageUrlBuilder2.prototype.saturation = function(saturation) {
        return this.withOptions({ saturation });
      }, ImageUrlBuilder2.prototype.auto = function(value) {
        if (validAutoModes.indexOf(value) === -1)
          throw new Error('Invalid auto mode "'.concat(value, '"'));
        return this.withOptions({ auto: value });
      }, ImageUrlBuilder2.prototype.pad = function(pad) {
        return this.withOptions({ pad });
      }, ImageUrlBuilder2.prototype.url = function() {
        return (0, urlForImage_1.default)(this.options);
      }, ImageUrlBuilder2.prototype.toString = function() {
        return this.url();
      }, ImageUrlBuilder2;
    }()
  );
  return builder.ImageUrlBuilder = ImageUrlBuilder, builder;
}
var node;
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var __importDefault = node && node.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  }, builder_1 = __importDefault(requireBuilder());
  return node = builder_1.default, node;
}
var nodeExports = requireNode();
var createImageUrlBuilder = getDefaultExportFromCjs(nodeExports);
var DEFAULT_PARAMS = {};
var DEFAULT_OPTIONS = { apiVersion: "v2023-05-01" };
var DEFAULT_INITIAL_VALUE = null;
function useParams(params) {
  const stringifiedParams = (0, import_react.useMemo)(
    () => JSON.stringify(params || {}),
    [params]
  );
  return (0, import_react.useMemo)(() => JSON.parse(stringifiedParams), [stringifiedParams]);
}
function useListeningQuery(query3, {
  params = DEFAULT_PARAMS,
  options = DEFAULT_OPTIONS,
  initialValue = DEFAULT_INITIAL_VALUE
}) {
  const [loading, setLoading] = (0, import_react.useState)(true), [error, setError] = (0, import_react.useState)(false), [data, setData] = (0, import_react.useState)(initialValue), memoParams = useParams(params), memoOptions = useParams(options), subscription = (0, import_react.useRef)(null), documentStore = useDocumentStore();
  return (0, import_react.useEffect)(() => {
    if (query3 && !error && !subscription.current)
      try {
        subscription.current = documentStore.listenQuery(query3, memoParams, memoOptions).pipe(
          distinctUntilChanged(import_react_fast_compare.default),
          catchError((err) => (console.error(err), setError(err), setLoading(false), setData(null), err))
        ).subscribe((documents) => {
          setData(
            (current) => (0, import_react_fast_compare.default)(current, documents) ? current : documents
          ), setLoading(false), setError(false);
        });
      } catch (err) {
        console.error(err), setLoading(false), setError(err);
      }
    return error && subscription.current && subscription.current.unsubscribe(), () => {
      var _a;
      subscription.current && ((_a = subscription == null ? void 0 : subscription.current) == null || _a.unsubscribe(), subscription.current = null);
    };
  }, [query3, error, memoParams, memoOptions, documentStore]), { data, loading, error };
}

// node_modules/suspend-react/index.js
var isPromise = (promise) => typeof promise === "object" && typeof promise.then === "function";
var globalCache = [];
function shallowEqualArrays(arrA, arrB, equal2 = (a2, b) => a2 === b) {
  if (arrA === arrB) return true;
  if (!arrA || !arrB) return false;
  const len = arrA.length;
  if (arrB.length !== len) return false;
  for (let i2 = 0; i2 < len; i2++) if (!equal2(arrA[i2], arrB[i2])) return false;
  return true;
}
function query(fn, keys = null, preload3 = false, config2 = {}) {
  if (keys === null) keys = [fn];
  for (const entry2 of globalCache) {
    if (shallowEqualArrays(keys, entry2.keys, entry2.equal)) {
      if (preload3) return void 0;
      if (Object.prototype.hasOwnProperty.call(entry2, "error")) throw entry2.error;
      if (Object.prototype.hasOwnProperty.call(entry2, "response")) {
        if (config2.lifespan && config2.lifespan > 0) {
          if (entry2.timeout) clearTimeout(entry2.timeout);
          entry2.timeout = setTimeout(entry2.remove, config2.lifespan);
        }
        return entry2.response;
      }
      if (!preload3) throw entry2.promise;
    }
  }
  const entry = {
    keys,
    equal: config2.equal,
    remove: () => {
      const index = globalCache.indexOf(entry);
      if (index !== -1) globalCache.splice(index, 1);
    },
    promise: (
      // Execute the promise
      (isPromise(fn) ? fn : fn(...keys)).then((response) => {
        entry.response = response;
        if (config2.lifespan && config2.lifespan > 0) {
          entry.timeout = setTimeout(entry.remove, config2.lifespan);
        }
      }).catch((error) => entry.error = error)
    )
  };
  globalCache.push(entry);
  if (!preload3) throw entry.promise;
  return void 0;
}
var suspend = (fn, keys, config2) => query(fn, keys, false, config2);
var preload = (fn, keys, config2) => void query(fn, keys, true, config2);
var peek = (keys) => {
  var _globalCache$find;
  return (_globalCache$find = globalCache.find((entry) => shallowEqualArrays(keys, entry.keys, entry.equal))) == null ? void 0 : _globalCache$find.response;
};

// node_modules/sanity-plugin-internationalized-array/lib/index.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);

// node_modules/@sanity/language-filter/lib/index.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);
var k = (e2, t2, n2) => !e2.name.startsWith("locale") || n2.includes(t2.name);
function C(e2, t2) {
  var n2, r2;
  const o2 = function(e3) {
    return "object" === (null == e3 ? void 0 : e3.jsonType) && "document" === F(e3).name;
  }(e2) && (null == (n2 = null == e2 ? void 0 : e2.options) ? void 0 : n2.languageFilter), l2 = !t2.documentTypes;
  return !!(l2 && false !== o2 || !l2 && o2 || e2 && null != (r2 = t2.documentTypes) && r2.includes(e2.name));
}
function F(e2) {
  return e2.type ? F(e2.type) : e2;
}
var N = "@sanity/plugin/language-filter/selected-languages";
function E(e2) {
  const t2 = z(e2).map((e3) => e3.id);
  let n2 = t2;
  try {
    const e3 = window.localStorage.getItem(N);
    e3 && (n2 = JSON.parse(e3));
  } catch (e3) {
  }
  return r2 = t2, n2 = n2.filter((e3) => r2.includes(e3)), n2;
  var r2;
}
function z({ supportedLanguages: e2, defaultLanguages: t2 }) {
  return Array.isArray(e2) ? e2.filter((e3) => !(null != t2 && t2.includes(e3.id))) : [];
}
var J = Object.defineProperty;
var V = Object.defineProperties;
var $ = Object.getOwnPropertyDescriptors;
var _ = Object.getOwnPropertySymbols;
var H = Object.prototype.hasOwnProperty;
var W = Object.prototype.propertyIsEnumerable;
var q = (e2, t2, n2) => t2 in e2 ? J(e2, t2, { enumerable: true, configurable: true, writable: true, value: n2 }) : e2[t2] = n2;
var B = (e2, t2) => {
  for (var n2 in t2 || (t2 = {})) H.call(t2, n2) && q(e2, n2, t2[n2]);
  if (_) for (var n2 of _(t2)) W.call(t2, n2) && q(e2, n2, t2[n2]);
  return e2;
};
var G = { options: { apiVersion: "2022-11-27", supportedLanguages: [], defaultLanguages: [], documentTypes: [], filterField: k }, selectedLanguageIds: [], setSelectedLanguageIds: () => console.error("LanguageFilterStudioContext not initialized") };
var K = (0, import_react2.createContext)(G);
function M(t2) {
  const n2 = useClient({ apiVersion: "2023-01-01" }), [o2, i2] = (0, import_react2.useState)(Array.isArray(t2.options.supportedLanguages) ? t2.options.supportedLanguages : []);
  (0, import_react2.useEffect)(() => {
    let e2 = [];
    Array.isArray(t2.options.supportedLanguages) || async function(t3) {
      e2 = await t3(n2, {}), i2(e2);
    }(t2.options.supportedLanguages);
  }, [n2, t2.options.supportedLanguages]);
  const s2 = (0, import_react2.useMemo)(() => {
    return e2 = B(B({}, G.options), t2.options), V(e2, $({ supportedLanguages: o2 }));
    var e2;
  }, [t2.options, o2]), [c, d] = function(e2) {
    return (0, import_react2.useState)(() => {
      var t3;
      return [...null != (t3 = e2.defaultLanguages) ? t3 : [], ...E(e2)];
    });
  }(s2);
  return (0, import_jsx_runtime2.jsx)(K.Provider, { value: { options: s2, selectedLanguageIds: c, setSelectedLanguageIds: d }, children: t2.renderDefault(t2) });
}
function Q() {
  return (0, import_react2.useContext)(K);
}
var R = (e2) => Array.from(new Set(e2));
function U() {
  const { selectedLanguageIds: e2, setSelectedLanguageIds: t2, options: n2 } = Q(), { defaultLanguages: r2 = [] } = n2, o2 = (0, import_react2.useMemo)(() => z(n2), [n2]), l2 = (0, import_react2.useCallback)((e3) => {
    var n3;
    t2(R([...r2, ...e3])), n3 = R([...r2, ...e3]), window.localStorage.setItem(N, JSON.stringify(n3));
  }, [r2, t2]), i2 = (0, import_react2.useCallback)(() => l2(o2.map((e3) => e3.id)), [l2, o2]), u = (0, import_react2.useCallback)(() => {
    l2(r2);
  }, [r2, l2]), c = (0, import_react2.useCallback)((t3) => {
    let n3 = e2;
    n3 = n3.includes(t3) ? n3.filter((e3) => e3 !== t3) : R([...n3, t3]), l2(n3);
  }, [l2, e2]);
  return { activeLanguages: (0, import_react2.useMemo)(() => R([...null != r2 ? r2 : [], ...e2]), [r2, e2]), allSelected: e2.length === o2.length + r2.length, selectAll: i2, selectNone: u, toggleLanguage: c };
}
var X = dt(Box)`
  max-height: calc(100vh - 200px);
`;
function Y() {
  const { options: o2 } = Q(), l2 = o2.supportedLanguages.filter((e2) => {
    var t2;
    return null == (t2 = o2.defaultLanguages) ? void 0 : t2.includes(e2.id);
  }), a2 = o2.supportedLanguages.filter((e2) => {
    var t2;
    return !(null != (t2 = o2.defaultLanguages) && t2.includes(e2.id));
  }), [i2, u] = (0, import_react2.useState)(false), { activeLanguages: d, allSelected: p, selectAll: g, selectNone: f, toggleLanguage: h } = U(), [v, A] = (0, import_react2.useState)(null), [D, k2] = (0, import_react2.useState)(null), C2 = (0, import_react2.useCallback)((e2) => {
    "ALL" === e2.currentTarget.value ? g() : f();
  }, [g, f]), F2 = (0, import_react2.useCallback)(() => u((e2) => !e2), []), N2 = (0, import_react2.useCallback)(() => u(false), []);
  useClickOutside(N2, [v, D]);
  const E2 = o2.supportedLanguages.length, [z2, J2] = (0, import_react2.useState)(""), V2 = (0, import_react2.useCallback)((e2) => {
    e2.currentTarget.value ? J2(e2.currentTarget.value) : J2("");
  }, []), $2 = E2 > 4, _2 = (0, import_jsx_runtime2.jsx)(X, { overflow: "auto", children: (0, import_jsx_runtime2.jsxs)(Stack, { padding: 1, space: 1, children: [l2.length > 0 && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [l2.map((t2) => (0, import_jsx_runtime2.jsx)(Z, { id: t2.id, title: t2.title, selected: true }, t2.id)), (0, import_jsx_runtime2.jsx)(Card, { borderTop: true })] }), (0, import_jsx_runtime2.jsx)(Button, { mode: "bleed", onClick: C2, justify: "flex-start", value: p ? "NONE" : "ALL", disabled: !!z2, children: (0, import_jsx_runtime2.jsxs)(Flex, { gap: 3, align: "center", children: [(0, import_jsx_runtime2.jsx)(Text, { size: 2, children: p ? (0, import_jsx_runtime2.jsx)(TextWithTone, { tone: "primary", children: (0, import_jsx_runtime2.jsx)(EyeClosedIcon, {}) }) : (0, import_jsx_runtime2.jsx)(EyeOpenIcon, {}) }), (0, import_jsx_runtime2.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime2.jsx)(Text, { children: p ? "Hide all" : "Show all" }) })] }) }), $2 ? (0, import_jsx_runtime2.jsx)(TextInput, { onChange: V2, value: z2, placeholder: "Filter languages" }) : (0, import_jsx_runtime2.jsx)(Card, { borderTop: true }), a2.filter((e2) => !z2 || e2.title.toLowerCase().includes(z2.toLowerCase())).map((t2) => (0, import_jsx_runtime2.jsx)(Z, { id: t2.id, onToggle: h, selected: d.includes(t2.id), title: t2.title }, t2.id))] }) }), H2 = d.length === E2 ? "Showing all" : `Showing ${d.length} / ${E2}`;
  return (0, import_jsx_runtime2.jsx)(Popover, { animate: true, content: _2, open: i2, portal: true, ref: k2, children: (0, import_jsx_runtime2.jsx)(Button, { text: H2, icon: TranslateIcon, mode: "bleed", onClick: F2, ref: A, selected: i2 }) });
}
function Z(n2) {
  const { id: r2, onToggle: o2, selected: l2, title: a2 } = n2, i2 = (0, import_react2.useCallback)(() => {
    o2 && o2(r2);
  }, [r2, o2]), u = !o2;
  return (0, import_jsx_runtime2.jsx)(Button, { mode: "bleed", onClick: i2, justify: "flex-start", disabled: u, children: (0, import_jsx_runtime2.jsxs)(Flex, { gap: 3, align: "center", children: [(0, import_jsx_runtime2.jsx)(Text, { size: 2, children: l2 ? (0, import_jsx_runtime2.jsx)(TextWithTone, { tone: u ? "default" : "positive", children: (0, import_jsx_runtime2.jsx)(CheckmarkCircleIcon, {}) }) : (0, import_jsx_runtime2.jsx)(CircleIcon, {}) }), (0, import_jsx_runtime2.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime2.jsx)(Text, { children: a2 }) }), (0, import_jsx_runtime2.jsx)(Badge, { children: r2 })] }) });
}
var ee = Object.defineProperty;
var te = Object.defineProperties;
var ne = Object.getOwnPropertyDescriptors;
var re = Object.getOwnPropertySymbols;
var oe = Object.prototype.hasOwnProperty;
var le = Object.prototype.propertyIsEnumerable;
var ae = (e2, t2, n2) => t2 in e2 ? ee(e2, t2, { enumerable: true, configurable: true, writable: true, value: n2 }) : e2[t2] = n2;
var ie = (e2, t2) => {
  for (var n2 in t2 || (t2 = {})) oe.call(t2, n2) && ae(e2, n2, t2[n2]);
  if (re) for (var n2 of re(t2)) le.call(t2, n2) && ae(e2, n2, t2[n2]);
  return e2;
};
var se = (e2, t2) => te(e2, ne(t2));
var ue = (e2, t2) => {
  var n2 = {};
  for (var r2 in e2) oe.call(e2, r2) && t2.indexOf(r2) < 0 && (n2[r2] = e2[r2]);
  if (null != e2 && re) for (var r2 of re(e2)) t2.indexOf(r2) < 0 && le.call(e2, r2) && (n2[r2] = e2[r2]);
  return n2;
};
function ce(e2) {
  const t2 = e2, { members: n2, schemaType: r2, renderDefault: o2 } = t2, l2 = ue(t2, ["members", "schemaType", "renderDefault"]), { selectedLanguageIds: i2, options: s2 } = Q(), { filterField: u } = s2, c = (0, import_react2.useMemo)(() => n2.filter((e3) => "field" === e3.kind && u(r2, e3, i2) || "fieldSet" === e3.kind || "error" === e3.kind).map((e3) => "fieldSet" === e3.kind ? se(ie({}, e3), { fieldSet: se(ie({}, e3.fieldSet), { members: e3.fieldSet.members.filter((e4) => "field" === e4.kind && u(r2, e4, i2)) }) }) : e3), [r2, n2, u, i2]);
  return o2(se(ie({}, l2), { members: c, schemaType: r2, renderDefault: o2 }));
}
var de = Object.defineProperty;
var pe = Object.defineProperties;
var ge = Object.getOwnPropertyDescriptors;
var fe = Object.getOwnPropertySymbols;
var me = Object.prototype.hasOwnProperty;
var ye = Object.prototype.propertyIsEnumerable;
var be = (e2, t2, n2) => t2 in e2 ? de(e2, t2, { enumerable: true, configurable: true, writable: true, value: n2 }) : e2[t2] = n2;
var he = (e2, t2) => {
  for (var n2 in t2 || (t2 = {})) me.call(t2, n2) && be(e2, n2, t2[n2]);
  if (fe) for (var n2 of fe(t2)) ye.call(t2, n2) && be(e2, n2, t2[n2]);
  return e2;
};
var ve = definePlugin((t2) => {
  const n2 = () => (0, import_jsx_runtime2.jsx)(Y, {}), r2 = he(he({}, G.options), t2);
  return { name: "@sanity/language-filter", studio: { components: { layout: (e2) => {
    return M((t3 = he({}, e2), pe(t3, ge({ options: r2 }))));
    var t3;
  } } }, document: { unstable_languageFilter: (e2, { schemaType: r3, schema: o2 }) => C(o2.get(r3), t2) ? [...e2, n2] : e2 }, form: { components: { input: (t3) => "root" !== t3.id && isObjectSchemaType(t3.schemaType) ? function(t4) {
    const { options: n3 } = Q(), r3 = useFormValue(["_type"]);
    return C(useSchema().get(r3), n3) ? (0, import_jsx_runtime2.jsx)(ce, ie({}, t4)) : t4.renderDefault(t4);
  }(t3) : t3.renderDefault(t3) } } };
});

// node_modules/sanity-plugin-internationalized-array/lib/index.mjs
var import_fast_deep_equal = __toESM(require_fast_deep_equal(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_get = __toESM(require_get(), 1);
var namespace = "sanity-plugin-internationalized-array";
var version = "v1";
var preload2 = (fn) => preload(() => fn(), [version, namespace]);
var peek2 = (selectedValue) => peek([version, namespace, selectedValue]);
var MAX_COLUMNS = {
  codeOnly: 5,
  titleOnly: 4,
  titleAndCode: 3
};
var CONFIG_DEFAULT = {
  languages: [],
  select: {},
  defaultLanguages: [],
  fieldTypes: [],
  apiVersion: "2022-11-27",
  buttonLocations: ["field"],
  buttonAddAll: true,
  languageDisplay: "codeOnly"
};
var __defProp$9 = Object.defineProperty;
var __defProps$8 = Object.defineProperties;
var __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$9 = (a2, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$9.call(b, prop) && __defNormalProp$9(a2, prop, b[prop]);
  if (__getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(b))
      __propIsEnum$9.call(b, prop) && __defNormalProp$9(a2, prop, b[prop]);
  return a2;
};
var __spreadProps$8 = (a2, b) => __defProps$8(a2, __getOwnPropDescs$8(b));
var getDocumentsToTranslate = (value, rootPath = []) => {
  if (Array.isArray(value)) {
    const arrayRootPath = [...rootPath], internationalizedValues = value.filter((item) => {
      if (Array.isArray(item)) return false;
      if (typeof item == "object") {
        const type = item == null ? void 0 : item._type;
        return (type == null ? void 0 : type.startsWith("internationalizedArray")) && (type == null ? void 0 : type.endsWith("Value"));
      }
      return false;
    });
    return internationalizedValues.length > 0 ? internationalizedValues.map((internationalizedValue) => __spreadProps$8(__spreadValues$9({}, internationalizedValue), {
      path: arrayRootPath,
      pathString: arrayRootPath.join(".")
    })) : value.length > 0 ? value.map(
      (item, index) => getDocumentsToTranslate(item, [...arrayRootPath, index])
    ).flat() : [];
  }
  if (typeof value == "object" && value) {
    const startsWithUnderscoreRegex = /^_/;
    return Object.keys(value).filter(
      (key) => !key.match(startsWithUnderscoreRegex)
    ).map((item) => {
      const selectedValue = value[item], path = [...rootPath, item];
      return getDocumentsToTranslate(selectedValue, path);
    }).flat();
  }
  return [];
};
function getLanguageDisplay(languageDisplay, title, code) {
  return languageDisplay === "codeOnly" ? code.toUpperCase() : languageDisplay === "titleOnly" ? title : languageDisplay === "titleAndCode" ? `${title} (${code.toUpperCase()})` : title;
}
function AddButtons(props) {
  const { languages, readOnly, value, onClick } = props, { languageDisplay } = useInternationalizedArrayContext();
  return languages.length > 0 ? (0, import_jsx_runtime3.jsx)(
    Grid,
    {
      columns: Math.min(languages.length, MAX_COLUMNS[languageDisplay]),
      gap: 2,
      children: languages.map((language) => {
        const languageTitle = getLanguageDisplay(
          languageDisplay,
          language.title,
          language.id
        );
        return (0, import_jsx_runtime3.jsx)(
          Button,
          {
            tone: "primary",
            mode: "ghost",
            fontSize: 1,
            disabled: readOnly || !!(value != null && value.find((item) => item._key === language.id)),
            text: languageTitle,
            icon: languages.length > MAX_COLUMNS[languageDisplay] && languageDisplay === "codeOnly" ? void 0 : AddIcon,
            value: language.id,
            onClick
          },
          language.id
        );
      })
    }
  ) : null;
}
var AddButtons$1 = (0, import_react3.memo)(AddButtons);
function DocumentAddButtons(props) {
  const { filteredLanguages } = useInternationalizedArrayContext(), value = isSanityDocument(props.value) ? props.value : void 0, toast = useToast(), { onChange } = useDocumentPane(), documentsToTranslation = getDocumentsToTranslate(value, []), handleDocumentButtonClick = (0, import_react3.useCallback)(
    async (event) => {
      const languageId = event.currentTarget.value;
      if (!languageId) {
        toast.push({
          status: "error",
          title: "No language selected"
        });
        return;
      }
      const alreadyTranslated = documentsToTranslation.filter(
        (translation) => (translation == null ? void 0 : translation._key) === languageId
      ), removeDuplicates = documentsToTranslation.reduce((filteredTranslations, translation) => alreadyTranslated.filter(
        (alreadyTranslation) => alreadyTranslation.pathString === translation.pathString
      ).length > 0 || filteredTranslations.filter(
        (filteredTranslation) => filteredTranslation.path === translation.path
      ).length > 0 ? filteredTranslations : [...filteredTranslations, translation], []);
      if (removeDuplicates.length === 0) {
        toast.push({
          status: "error",
          title: "No internationalizedArray fields found in document root"
        });
        return;
      }
      const patches = [];
      for (const toTranslate of removeDuplicates) {
        const path = toTranslate.path, ifMissing = setIfMissing([], path), insertValue = insert$1(
          [
            {
              _key: languageId,
              _type: toTranslate._type,
              value: void 0
            }
          ],
          "after",
          [...path, -1]
        );
        patches.push(ifMissing), patches.push(insertValue);
      }
      onChange(PatchEvent.from(patches.flat()));
    },
    [documentsToTranslation, onChange, toast]
  );
  return (0, import_jsx_runtime3.jsxs)(Stack, { space: 3, children: [
    (0, import_jsx_runtime3.jsx)(Box, { children: (0, import_jsx_runtime3.jsx)(Text, { size: 1, weight: "semibold", children: "Add translation to internationalized fields" }) }),
    (0, import_jsx_runtime3.jsx)(
      AddButtons$1,
      {
        languages: filteredLanguages,
        readOnly: false,
        value: void 0,
        onClick: handleDocumentButtonClick
      }
    )
  ] });
}
var getSelectedValue = (select, document) => {
  if (!select || !document)
    return {};
  const selection = select || {}, selectedValue = {};
  for (const [key, path] of Object.entries(selection)) {
    let value = (0, import_get.default)(document, path);
    Array.isArray(value) && (value = value.filter(
      (item) => typeof item == "object" ? (item == null ? void 0 : item._type) === "reference" && "_ref" in item : true
    )), selectedValue[key] = value;
  }
  return selectedValue;
};
var __defProp$8 = Object.defineProperty;
var __defProps$7 = Object.defineProperties;
var __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$8 = (a2, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$8.call(b, prop) && __defNormalProp$8(a2, prop, b[prop]);
  if (__getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(b))
      __propIsEnum$8.call(b, prop) && __defNormalProp$8(a2, prop, b[prop]);
  return a2;
};
var __spreadProps$7 = (a2, b) => __defProps$7(a2, __getOwnPropDescs$7(b));
var InternationalizedArrayContext = (0, import_react3.createContext)(__spreadProps$7(__spreadValues$8({}, CONFIG_DEFAULT), {
  languages: [],
  filteredLanguages: []
}));
function useInternationalizedArrayContext() {
  return (0, import_react3.useContext)(InternationalizedArrayContext);
}
function InternationalizedArrayProvider(props) {
  const { internationalizedArray: internationalizedArray2 } = props, client = useClient({ apiVersion: internationalizedArray2.apiVersion }), workspace = useWorkspace(), { formState } = useDocumentPane(), deferredDocument = (0, import_react3.useDeferredValue)(formState == null ? void 0 : formState.value), selectedValue = (0, import_react3.useMemo)(
    () => getSelectedValue(internationalizedArray2.select, deferredDocument),
    [internationalizedArray2.select, deferredDocument]
  ), languages = Array.isArray(internationalizedArray2.languages) ? internationalizedArray2.languages : suspend(
    // eslint-disable-next-line require-await
    async () => typeof internationalizedArray2.languages == "function" ? internationalizedArray2.languages(client, selectedValue) : internationalizedArray2.languages,
    [version, namespace, selectedValue, workspace],
    { equal: import_fast_deep_equal.default }
  ), { selectedLanguageIds, options: languageFilterOptions } = Q(), filteredLanguages = (0, import_react3.useMemo)(() => {
    const documentType = deferredDocument ? deferredDocument._type : void 0;
    return typeof documentType == "string" && languageFilterOptions.documentTypes.includes(documentType) ? languages.filter(
      (language) => selectedLanguageIds.includes(language.id)
    ) : languages;
  }, [deferredDocument, languageFilterOptions, languages, selectedLanguageIds]), showDocumentButtons = internationalizedArray2.buttonLocations.includes("document"), context = (0, import_react3.useMemo)(
    () => __spreadProps$7(__spreadValues$8({}, internationalizedArray2), { languages, filteredLanguages }),
    [filteredLanguages, internationalizedArray2, languages]
  );
  return (0, import_jsx_runtime3.jsx)(InternationalizedArrayContext.Provider, { value: context, children: showDocumentButtons ? (0, import_jsx_runtime3.jsxs)(Stack, { space: 5, children: [
    (0, import_jsx_runtime3.jsx)(DocumentAddButtons, { value: props.value }),
    props.renderDefault(props)
  ] }) : props.renderDefault(props) });
}
var __defProp$7 = Object.defineProperty;
var __defProps$6 = Object.defineProperties;
var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$7 = (a2, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$7.call(b, prop) && __defNormalProp$7(a2, prop, b[prop]);
  if (__getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(b))
      __propIsEnum$7.call(b, prop) && __defNormalProp$7(a2, prop, b[prop]);
  return a2;
};
var __spreadProps$6 = (a2, b) => __defProps$6(a2, __getOwnPropDescs$6(b));
function InternationalizedField(props) {
  const { languages } = useInternationalizedArrayContext(), customProps = (0, import_react3.useMemo)(() => {
    var _a;
    const pathSegment = props.path.slice(0, -1)[1], languageId = typeof pathSegment == "object" && "_key" in pathSegment ? pathSegment._key : void 0, hasValidLanguageId = languageId ? languages.some((l2) => l2.id === languageId) : false, shouldHideTitle = ((_a = props.title) == null ? void 0 : _a.toLowerCase()) === "value" && hasValidLanguageId;
    return __spreadProps$6(__spreadValues$7({}, props), {
      title: shouldHideTitle ? "" : props.title
    });
  }, [props, languages]);
  return customProps.schemaType.name.startsWith("internationalizedArray") ? customProps.schemaType.name === "reference" && customProps.value ? customProps.renderDefault(__spreadProps$6(__spreadValues$7({}, customProps), {
    title: "",
    level: 0
    // Reset the level to avoid nested styling
  })) : customProps.schemaType.name === "string" || customProps.schemaType.name === "number" || customProps.schemaType.name === "text" ? customProps.children : customProps.renderDefault(__spreadProps$6(__spreadValues$7({}, customProps), {
    level: 0
    // Reset the level to avoid nested styling
  })) : customProps.renderDefault(customProps);
}
var Preload = (0, import_react3.memo)(function(props) {
  const client = useClient({ apiVersion: props.apiVersion });
  return Array.isArray(peek2({})) || preload2(
    async () => Array.isArray(props.languages) ? props.languages : props.languages(client, {})
  ), null;
});
function checkAllLanguagesArePresent(languages, value) {
  const filteredLanguageIds = languages.map((l2) => l2.id), languagesInUseIds = value ? value.map((v) => v._key) : [];
  return languagesInUseIds.length === filteredLanguageIds.length && languagesInUseIds.every((l2) => filteredLanguageIds.includes(l2));
}
function createAddAllTitle(value, languages) {
  return value != null && value.length ? `Add missing ${languages.length - value.length === 1 ? "language" : "languages"}` : languages.length === 1 ? `Add ${languages[0].title} Field` : "Add all languages";
}
function createValueSchemaTypeName(schemaType) {
  return `${schemaType.name}Value`;
}
var __defProp$6 = Object.defineProperty;
var __defProps$5 = Object.defineProperties;
var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$6 = (a2, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$6.call(b, prop) && __defNormalProp$6(a2, prop, b[prop]);
  if (__getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(b))
      __propIsEnum$6.call(b, prop) && __defNormalProp$6(a2, prop, b[prop]);
  return a2;
};
var __spreadProps$5 = (a2, b) => __defProps$5(a2, __getOwnPropDescs$5(b));
function createAddLanguagePatches(config2) {
  const {
    addLanguageKeys,
    schemaType,
    languages,
    filteredLanguages,
    value,
    path = []
  } = config2, itemBase = { _type: createValueSchemaTypeName(schemaType) }, newItems = Array.isArray(addLanguageKeys) && addLanguageKeys.length > 0 ? addLanguageKeys.map((id) => __spreadProps$5(__spreadValues$6({}, itemBase), {
    _key: id
  })) : filteredLanguages.filter(
    (language) => value != null && value.length ? !value.find((v) => v._key === language.id) : true
  ).map((language) => __spreadProps$5(__spreadValues$6({}, itemBase), {
    _key: language.id
  })), languagesInUse = value != null && value.length ? value.map((v) => v) : [];
  return newItems.map((item) => {
    const languageIndex = languages.findIndex((l2) => item._key === l2.id), remainingLanguages = languages.slice(languageIndex + 1), nextLanguageIndex = languagesInUse.findIndex(
      (l2) => (
        // eslint-disable-next-line max-nested-callbacks
        remainingLanguages.find((r2) => r2.id === l2._key)
      )
    );
    return nextLanguageIndex < 0 ? languagesInUse.push(item) : languagesInUse.splice(nextLanguageIndex, 0, item), nextLanguageIndex < 0 ? (
      // No next language (-1), add to end of array
      insert$1([item], "after", [...path, nextLanguageIndex])
    ) : (
      // Next language found, insert before that
      insert$1([item], "before", [...path, nextLanguageIndex])
    );
  });
}
var createTranslateFieldActions = (fieldActionProps, { languages, filteredLanguages }) => languages.map((language) => {
  const value = useFormValue(fieldActionProps.path), disabled = value && Array.isArray(value) ? !!(value != null && value.find((item) => item._key === language.id)) : false, hidden = !filteredLanguages.some((f) => f.id === language.id), { onChange } = useDocumentPane(), onAction = (0, import_react3.useCallback)(() => {
    const { schemaType, path } = fieldActionProps, addLanguageKeys = [language.id], patches = createAddLanguagePatches({
      addLanguageKeys,
      schemaType,
      languages,
      filteredLanguages,
      value,
      path
    });
    onChange(PatchEvent.from([setIfMissing([], path), ...patches]));
  }, [language.id, value, onChange]);
  return {
    type: "action",
    icon: AddIcon,
    onAction,
    title: language.title,
    hidden,
    disabled
  };
});
var AddMissingTranslationsFieldAction = (fieldActionProps, { languages, filteredLanguages }) => {
  const value = useFormValue(fieldActionProps.path), disabled = value && value.length === filteredLanguages.length, hidden = checkAllLanguagesArePresent(filteredLanguages, value), { onChange } = useDocumentPane(), onAction = (0, import_react3.useCallback)(() => {
    const { schemaType, path } = fieldActionProps, patches = createAddLanguagePatches({
      addLanguageKeys: [],
      schemaType,
      languages,
      filteredLanguages,
      value,
      path
    });
    onChange(PatchEvent.from([setIfMissing([], path), ...patches]));
  }, [fieldActionProps, filteredLanguages, languages, onChange, value]);
  return {
    type: "action",
    icon: AddIcon,
    onAction,
    title: createAddAllTitle(value, filteredLanguages),
    disabled,
    hidden
  };
};
var internationalizedArrayFieldAction = defineDocumentFieldAction({
  name: "internationalizedArray",
  useAction(fieldActionProps) {
    var _a, _b;
    const isInternationalizedArrayField = (_b = (_a = fieldActionProps == null ? void 0 : fieldActionProps.schemaType) == null ? void 0 : _a.type) == null ? void 0 : _b.name.startsWith(
      "internationalizedArray"
    ), { languages, filteredLanguages } = useInternationalizedArrayContext(), translateFieldActions = createTranslateFieldActions(
      fieldActionProps,
      { languages, filteredLanguages }
    );
    return {
      type: "group",
      icon: TranslateIcon,
      title: "Add Translation",
      renderAsButton: true,
      children: isInternationalizedArrayField ? [
        ...translateFieldActions,
        AddMissingTranslationsFieldAction(fieldActionProps, {
          languages,
          filteredLanguages
        })
      ] : [],
      hidden: !isInternationalizedArrayField
    };
  }
});
function camelCase(string) {
  return string.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
}
function titleCase(string) {
  return string.split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
}
function pascalCase(string) {
  return titleCase(camelCase(string));
}
function createFieldName(name, addValue = false) {
  return addValue ? ["internationalizedArray", pascalCase(name), "Value"].join("") : ["internationalizedArray", pascalCase(name)].join("");
}
var schemaExample = {
  languages: [
    { id: "en", title: "English" },
    { id: "no", title: "Norsk" }
  ]
};
function Feedback2() {
  return (0, import_jsx_runtime3.jsx)(Card, { tone: "caution", border: true, radius: 2, padding: 3, children: (0, import_jsx_runtime3.jsxs)(Stack, { space: 4, children: [
    (0, import_jsx_runtime3.jsxs)(Text, { children: [
      "An array of language objects must be passed into the",
      " ",
      (0, import_jsx_runtime3.jsx)("code", { children: "internationalizedArray" }),
      " helper function, each with an",
      " ",
      (0, import_jsx_runtime3.jsx)("code", { children: "id" }),
      " and ",
      (0, import_jsx_runtime3.jsx)("code", { children: "title" }),
      " field. Example:"
    ] }),
    (0, import_jsx_runtime3.jsx)(Card, { padding: 2, border: true, radius: 2, children: (0, import_jsx_runtime3.jsx)(Code, { size: 1, language: "javascript", children: JSON.stringify(schemaExample, null, 2) }) })
  ] }) });
}
var __defProp$5 = Object.defineProperty;
var __defProps$4 = Object.defineProperties;
var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$5 = (a2, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$5.call(b, prop) && __defNormalProp$5(a2, prop, b[prop]);
  if (__getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(b))
      __propIsEnum$5.call(b, prop) && __defNormalProp$5(a2, prop, b[prop]);
  return a2;
};
var __spreadProps$4 = (a2, b) => __defProps$4(a2, __getOwnPropDescs$4(b));
function InternationalizedArray(props) {
  const { members, value, schemaType, onChange } = props, readOnly = typeof schemaType.readOnly == "boolean" ? schemaType.readOnly : false, toast = useToast(), {
    languages,
    filteredLanguages,
    defaultLanguages,
    buttonAddAll,
    buttonLocations
  } = useInternationalizedArrayContext(), { selectedLanguageIds, options: languageFilterOptions } = Q(), documentType = useFormValue(["_type"]), languageFilterEnabled = typeof documentType == "string" && languageFilterOptions.documentTypes.includes(documentType), filteredMembers = (0, import_react3.useMemo)(
    () => languageFilterEnabled ? members.filter((member) => {
      if (member.kind !== "item")
        return false;
      const valueMember = member.item.members[0];
      return valueMember.kind !== "field" ? false : languageFilterOptions.filterField(
        member.item.schemaType,
        valueMember,
        selectedLanguageIds
      );
    }) : members,
    [languageFilterEnabled, members, languageFilterOptions, selectedLanguageIds]
  ), handleAddLanguage = (0, import_react3.useCallback)(
    async (param) => {
      var _a;
      if (!(filteredLanguages != null && filteredLanguages.length))
        return;
      const addLanguageKeys = Array.isArray(param) ? param : [(_a = param == null ? void 0 : param.currentTarget) == null ? void 0 : _a.value].filter(Boolean), patches = createAddLanguagePatches({
        addLanguageKeys,
        schemaType,
        languages,
        filteredLanguages,
        value
      });
      onChange([setIfMissing([]), ...patches]);
    },
    [filteredLanguages, languages, onChange, schemaType, value]
  ), { isDeleting } = useDocumentPane(), addedLanguages = members.map(({ key }) => key), hasAddedDefaultLanguages = defaultLanguages.filter((language) => languages.find((l2) => l2.id === language)).every((language) => addedLanguages.includes(language));
  (0, import_react3.useEffect)(() => {
    if (!isDeleting && !hasAddedDefaultLanguages) {
      const languagesToAdd = defaultLanguages.filter((language) => !addedLanguages.includes(language)).filter((language) => languages.find((l2) => l2.id === language)), timeout = setTimeout(() => handleAddLanguage(languagesToAdd));
      return () => clearTimeout(timeout);
    }
  }, [
    isDeleting,
    hasAddedDefaultLanguages,
    handleAddLanguage,
    defaultLanguages,
    addedLanguages,
    languages
  ]);
  const handleRestoreOrder = (0, import_react3.useCallback)(() => {
    if (!(value != null && value.length) || !(languages != null && languages.length))
      return;
    const updatedValue = value.reduce((acc, v) => {
      const newIndex = languages.findIndex((l2) => l2.id === (v == null ? void 0 : v._key));
      return newIndex > -1 && (acc[newIndex] = v), acc;
    }, []).filter(Boolean);
    (value == null ? void 0 : value.length) !== updatedValue.length && toast.push({
      title: "There was an error reordering languages",
      status: "warning"
    }), onChange(set(updatedValue));
  }, [toast, languages, onChange, value]), allKeysAreLanguages = (0, import_react3.useMemo)(() => !(value != null && value.length) || !(languages != null && languages.length) ? true : value == null ? void 0 : value.every((v) => languages.find((l2) => (l2 == null ? void 0 : l2.id) === (v == null ? void 0 : v._key))), [value, languages]), languagesInUse = (0, import_react3.useMemo)(
    () => languages && languages.length > 1 ? languages.filter((l2) => value == null ? void 0 : value.find((v) => v._key === l2.id)) : [],
    [languages, value]
  ), languagesOutOfOrder = (0, import_react3.useMemo)(() => !(value != null && value.length) || !languagesInUse.length ? [] : value.map(
    (v, vIndex) => vIndex === languagesInUse.findIndex((l2) => l2.id === v._key) ? null : v
  ).filter(Boolean), [value, languagesInUse]), languagesAreValid = (0, import_react3.useMemo)(
    () => !(languages != null && languages.length) || (languages == null ? void 0 : languages.length) && languages.every((item) => item.id && item.title),
    [languages]
  );
  (0, import_react3.useEffect)(() => {
    languagesOutOfOrder.length > 0 && allKeysAreLanguages && handleRestoreOrder();
  }, [languagesOutOfOrder, allKeysAreLanguages, handleRestoreOrder]);
  const allLanguagesArePresent = (0, import_react3.useMemo)(
    () => checkAllLanguagesArePresent(filteredLanguages, value),
    [filteredLanguages, value]
  );
  if (!languagesAreValid)
    return (0, import_jsx_runtime3.jsx)(Feedback2, {});
  const addButtonsAreVisible = (
    // Plugin was configured to display buttons here (default!)
    buttonLocations.includes("field") && // There's at least one language visible
    (filteredLanguages == null ? void 0 : filteredLanguages.length) > 0 && // Not every language has a value yet
    !allLanguagesArePresent
  ), fieldHasMembers = (members == null ? void 0 : members.length) > 0;
  return (0, import_jsx_runtime3.jsxs)(Stack, { space: 2, children: [
    fieldHasMembers ? (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children: filteredMembers.map((member) => member.kind === "item" ? (0, import_react3.createElement)(
      ArrayOfObjectsItem,
      __spreadProps$4(__spreadValues$5({}, props), {
        key: member.key,
        member
      })
    ) : (0, import_jsx_runtime3.jsx)(MemberItemError, { member }, member.key)) }) : null,
    !addButtonsAreVisible && !fieldHasMembers ? (0, import_jsx_runtime3.jsx)(Card, { border: true, tone: "transparent", padding: 3, radius: 2, children: (0, import_jsx_runtime3.jsx)(Text, { size: 1, children: "This internationalized field currently has no translations." }) }) : null,
    addButtonsAreVisible ? (0, import_jsx_runtime3.jsxs)(Stack, { space: 2, children: [
      (0, import_jsx_runtime3.jsx)(
        AddButtons$1,
        {
          languages: filteredLanguages,
          value,
          readOnly,
          onClick: handleAddLanguage
        }
      ),
      buttonAddAll ? (0, import_jsx_runtime3.jsx)(
        Button,
        {
          tone: "primary",
          mode: "ghost",
          disabled: readOnly || allLanguagesArePresent,
          icon: AddIcon,
          text: createAddAllTitle(value, filteredLanguages),
          onClick: handleAddLanguage
        }
      ) : null
    ] }) : null
  ] });
}
function getLanguagesFieldOption(schemaType) {
  var _a;
  return schemaType ? ((_a = schemaType.options) == null ? void 0 : _a.languages) || getLanguagesFieldOption(schemaType.type) : void 0;
}
var __defProp$4 = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$4 = (a2, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$4.call(b, prop) && __defNormalProp$4(a2, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b))
      __propIsEnum$4.call(b, prop) && __defNormalProp$4(a2, prop, b[prop]);
  return a2;
};
var __spreadProps$3 = (a2, b) => __defProps$3(a2, __getOwnPropDescs$3(b));
var array = (config2) => {
  const { apiVersion, select, languages, type } = config2, typeName = typeof type == "string" ? type : type.name, arrayName = createFieldName(typeName), objectName = createFieldName(typeName, true);
  return defineField({
    name: arrayName,
    title: "Internationalized array",
    type: "array",
    components: {
      input: InternationalizedArray
    },
    options: {
      // @ts-expect-error - these options are required for validation rules  not the custom input component
      apiVersion,
      select,
      languages
    },
    of: [
      defineField(__spreadProps$3(__spreadValues$4({}, typeof type == "string" ? {} : type), {
        name: objectName,
        type: objectName
      }))
    ],
    // @ts-expect-error - fix typings
    validation: (rule) => rule.custom(async (value, context) => {
      if (!value)
        return true;
      const selectedValue = getSelectedValue(select, context.document), client = context.getClient({ apiVersion });
      let contextLanguages = [];
      const languagesFieldOption = getLanguagesFieldOption(context == null ? void 0 : context.type);
      if (Array.isArray(languagesFieldOption) ? contextLanguages = languagesFieldOption : Array.isArray(peek2(selectedValue)) ? contextLanguages = peek2(selectedValue) || [] : typeof languagesFieldOption == "function" && (contextLanguages = await languagesFieldOption(client, selectedValue)), value && value.length > contextLanguages.length)
        return `Cannot be more than ${contextLanguages.length === 1 ? "1 item" : `${contextLanguages.length} items`}`;
      const nonLanguageKeys = value != null && value.length ? value.filter(
        (item) => !contextLanguages.find((language) => item._key === language.id)
      ) : [];
      if (nonLanguageKeys.length)
        return {
          message: "Array item keys must be valid languages registered to the field type",
          paths: nonLanguageKeys.map((item) => [{ _key: item._key }])
        };
      const valuesByLanguage = value != null && value.length ? value.filter((item) => !!(item != null && item._key)).reduce((acc, cur) => acc[cur._key] ? __spreadProps$3(__spreadValues$4({}, acc), { [cur._key]: [...acc[cur._key], cur] }) : __spreadProps$3(__spreadValues$4({}, acc), {
        [cur._key]: [cur]
      }), {}) : {}, duplicateValues = Object.values(valuesByLanguage).filter((item) => (item == null ? void 0 : item.length) > 1).flat();
      return duplicateValues.length ? {
        message: "There can only be one field per language",
        paths: duplicateValues.map((item) => [{ _key: item._key }])
      } : true;
    })
  });
};
function getToneFromValidation(validations) {
  if (!(validations != null && validations.length))
    return;
  const validationLevels = validations.map((v) => v.level);
  if (validationLevels.includes("error"))
    return "critical";
  if (validationLevels.includes("warning"))
    return "caution";
}
var __defProp$32 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$32 = Object.getOwnPropertySymbols;
var __hasOwnProp$32 = Object.prototype.hasOwnProperty;
var __propIsEnum$32 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$32 = (obj, key, value) => key in obj ? __defProp$32(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$32 = (a2, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$32.call(b, prop) && __defNormalProp$32(a2, prop, b[prop]);
  if (__getOwnPropSymbols$32)
    for (var prop of __getOwnPropSymbols$32(b))
      __propIsEnum$32.call(b, prop) && __defNormalProp$32(a2, prop, b[prop]);
  return a2;
};
var __spreadProps$2 = (a2, b) => __defProps$2(a2, __getOwnPropDescs$2(b));
function InternationalizedInput(props) {
  const parentValue = useFormValue(
    props.path.slice(0, -1)
  ), inlineProps = __spreadProps$2(__spreadValues$32({}, props.inputProps), {
    // This is the magic that makes inline editing work?
    members: props.inputProps.members.filter(
      (m) => m.kind === "field" && m.name === "value"
    ),
    // This just overrides the type
    // Remove this as it shouldn't be necessary?
    value: props.value
  }), { validation, value, onChange, readOnly } = inlineProps, { languages, languageDisplay, defaultLanguages } = useInternationalizedArrayContext(), languageKeysInUse = (0, import_react3.useMemo)(
    () => {
      var _a;
      return (_a = parentValue == null ? void 0 : parentValue.map((v) => v._key)) != null ? _a : [];
    },
    [parentValue]
  ), keyIsValid = languages != null && languages.length ? languages.find((l2) => l2.id === value._key) : false, handleKeyChange = (0, import_react3.useCallback)(
    (event) => {
      var _a;
      const languageId = (_a = event == null ? void 0 : event.currentTarget) == null ? void 0 : _a.value;
      !value || !(languages != null && languages.length) || !languages.find((l2) => l2.id === languageId) || onChange([set(languageId, ["_key"])]);
    },
    [onChange, value, languages]
  ), handleUnset = (0, import_react3.useCallback)(() => {
    onChange(unset());
  }, [onChange]);
  if (!languages)
    return (0, import_jsx_runtime3.jsx)(Spinner, {});
  const language = languages.find((l2) => l2.id === value._key), languageTitle = keyIsValid && language ? getLanguageDisplay(languageDisplay, language.title, language.id) : "", isDefault = defaultLanguages.includes(value._key), removeButton = (0, import_jsx_runtime3.jsx)(
    Button,
    {
      mode: "bleed",
      icon: RemoveCircleIcon,
      tone: "critical",
      disabled: readOnly || isDefault,
      onClick: handleUnset
    }
  );
  return (0, import_jsx_runtime3.jsx)(Card, { paddingTop: 2, tone: getToneFromValidation(validation), children: (0, import_jsx_runtime3.jsxs)(Stack, { space: 2, children: [
    (0, import_jsx_runtime3.jsx)(Card, { tone: "inherit", children: keyIsValid ? (0, import_jsx_runtime3.jsx)(Label, { muted: true, size: 1, children: languageTitle }) : (0, import_jsx_runtime3.jsx)(
      MenuButton,
      {
        button: (0, import_jsx_runtime3.jsx)(Button, { fontSize: 1, text: `Change "${value._key}"` }),
        id: `${value._key}-change-key`,
        menu: (0, import_jsx_runtime3.jsx)(Menu, { children: languages.map((lang) => (0, import_jsx_runtime3.jsx)(
          MenuItem,
          {
            disabled: languageKeysInUse.includes(lang.id),
            fontSize: 1,
            text: lang.id.toLocaleUpperCase(),
            value: lang.id,
            onClick: handleKeyChange
          },
          lang.id
        )) }),
        popover: { portal: true }
      }
    ) }),
    (0, import_jsx_runtime3.jsxs)(Flex, { align: "center", gap: 2, children: [
      (0, import_jsx_runtime3.jsx)(Card, { flex: 1, tone: "inherit", children: props.inputProps.renderInput(props.inputProps) }),
      (0, import_jsx_runtime3.jsx)(Card, { tone: "inherit", children: isDefault ? (0, import_jsx_runtime3.jsx)(
        Tooltip,
        {
          content: (0, import_jsx_runtime3.jsx)(Text, { muted: true, size: 1, children: "Can't remove default language" }),
          fallbackPlacements: ["right", "left"],
          placement: "top",
          portal: true,
          children: (0, import_jsx_runtime3.jsx)("span", { children: removeButton })
        }
      ) : removeButton })
    ] })
  ] }) });
}
var __defProp$22 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$22 = Object.getOwnPropertySymbols;
var __hasOwnProp$22 = Object.prototype.hasOwnProperty;
var __propIsEnum$22 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$22 = (obj, key, value) => key in obj ? __defProp$22(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$22 = (a2, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$22.call(b, prop) && __defNormalProp$22(a2, prop, b[prop]);
  if (__getOwnPropSymbols$22)
    for (var prop of __getOwnPropSymbols$22(b))
      __propIsEnum$22.call(b, prop) && __defNormalProp$22(a2, prop, b[prop]);
  return a2;
};
var __spreadProps$1 = (a2, b) => __defProps$1(a2, __getOwnPropDescs$1(b));
var object = (config2) => {
  const { type } = config2, typeName = typeof type == "string" ? type : type.name, objectName = createFieldName(typeName, true);
  return defineField({
    name: objectName,
    title: `Internationalized array ${type}`,
    type: "object",
    components: {
      // @ts-expect-error - fix typings
      item: InternationalizedInput
    },
    fields: [
      defineField(__spreadProps$1(__spreadValues$22({}, typeof type == "string" ? { type } : type), {
        name: "value"
      }))
    ],
    preview: {
      select: {
        title: "value",
        subtitle: "_key"
      }
    }
  });
};
var __defProp$1 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a2, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$1.call(b, prop) && __defNormalProp$1(a2, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b))
      __propIsEnum$1.call(b, prop) && __defNormalProp$1(a2, prop, b[prop]);
  return a2;
};
function flattenSchemaType(schemaType) {
  return isDocumentSchemaType(schemaType) ? extractInnerFields(schemaType.fields, [], 3) : (console.error("Schema type is not a document"), []);
}
function extractInnerFields(fields, path, maxDepth) {
  return path.length >= maxDepth ? [] : fields.reduce((acc, field) => {
    const thisFieldWithPath = __spreadValues$1({ path: [...path, field.name] }, field);
    if (field.type.jsonType === "object") {
      const innerFields = extractInnerFields(
        field.type.fields,
        [...path, field.name],
        maxDepth
      );
      return [...acc, thisFieldWithPath, ...innerFields];
    } else if (field.type.jsonType === "array" && field.type.of.length && field.type.of.some((item) => "fields" in item)) {
      const innerFields = field.type.of.flatMap(
        (innerField) => extractInnerFields(
          // @ts-expect-error - Fix TS assertion for array fields
          innerField.fields,
          [...path, field.name],
          maxDepth
        )
      );
      return [...acc, thisFieldWithPath, ...innerFields];
    }
    return [...acc, thisFieldWithPath];
  }, []);
}
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp.call(b, prop) && __defNormalProp(a2, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b))
      __propIsEnum.call(b, prop) && __defNormalProp(a2, prop, b[prop]);
  return a2;
};
var __spreadProps = (a2, b) => __defProps(a2, __getOwnPropDescs(b));
var internationalizedArray = definePlugin((config2) => {
  const pluginConfig = __spreadValues(__spreadValues({}, CONFIG_DEFAULT), config2), {
    apiVersion = "2022-11-27",
    select,
    languages,
    fieldTypes,
    defaultLanguages,
    buttonLocations
  } = pluginConfig;
  return {
    name: "sanity-plugin-internationalized-array",
    // Preload languages for use throughout the Studio
    studio: Array.isArray(languages) ? void 0 : {
      components: {
        layout: (props) => (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [
          (0, import_jsx_runtime3.jsx)(Preload, { apiVersion, languages }),
          props.renderDefault(props)
        ] })
      }
    },
    // Optional: render "add language" buttons as field actions
    document: {
      unstable_fieldActions: buttonLocations.includes("unstable__fieldAction") ? (prev) => [...prev, internationalizedArrayFieldAction] : void 0
    },
    // Wrap document editor with a language provider
    form: {
      components: {
        field: (props) => (0, import_jsx_runtime3.jsx)(InternationalizedField, __spreadValues({}, props)),
        input: (props) => !(props.id === "root" && isObjectInputProps(props)) || !flattenSchemaType(props.schemaType).map(
          (field) => field.type.name
        ).some(
          (name) => name.startsWith("internationalizedArray")
        ) ? props.renderDefault(props) : (0, import_jsx_runtime3.jsx)(
          InternationalizedArrayProvider,
          __spreadProps(__spreadValues({}, props), {
            internationalizedArray: pluginConfig
          })
        )
      }
    },
    // Register custom schema types for the outer array and the inner object
    schema: {
      types: [
        ...fieldTypes.map(
          (type) => array({ type, apiVersion, select, languages, defaultLanguages })
        ),
        ...fieldTypes.map((type) => object({ type }))
      ]
    }
  };
});

// node_modules/@sanity/document-internationalization/dist/index.mjs
function DocumentPreview(props) {
  const schemaType = useSchema().get(props.type);
  return schemaType ? (0, import_jsx_runtime4.jsx)(Preview$1, { value: props.value, schemaType }) : (0, import_jsx_runtime4.jsx)(Feedback, { tone: "critical", title: "Schema type not found" });
}
var METADATA_SCHEMA_NAME = "translation.metadata";
var TRANSLATIONS_ARRAY_NAME = "translations";
var API_VERSION = "2023-05-22";
var DEFAULT_CONFIG = {
  supportedLanguages: [],
  schemaTypes: [],
  languageField: "language",
  weakReferences: false,
  bulkPublish: false,
  metadataFields: [],
  apiVersion: API_VERSION,
  allowCreateMetaDoc: false,
  callback: null
};
function separateReferences(data = []) {
  const translations = [], otherReferences = [];
  return data && data.length > 0 && data.forEach((doc) => {
    doc._type === METADATA_SCHEMA_NAME ? translations.push(doc) : otherReferences.push(doc);
  }), { translations, otherReferences };
}
function DeleteTranslationDialog(props) {
  const { doc, documentId, setTranslations } = props, { data, loading } = useListeningQuery(
    "*[references($id)]{_id, _type}",
    { params: { id: documentId }, initialValue: [] }
  ), { translations, otherReferences } = (0, import_react4.useMemo)(
    () => separateReferences(data),
    [data]
  );
  return (0, import_react4.useEffect)(() => {
    setTranslations(translations);
  }, [setTranslations, translations]), loading ? (0, import_jsx_runtime4.jsx)(Flex, { padding: 4, align: "center", justify: "center", children: (0, import_jsx_runtime4.jsx)(Spinner, {}) }) : (0, import_jsx_runtime4.jsxs)(Stack, { space: 4, children: [
    translations && translations.length > 0 ? (0, import_jsx_runtime4.jsx)(Text, { children: "This document is a language-specific version which other translations depend on." }) : (0, import_jsx_runtime4.jsx)(Text, { children: "This document does not have connected translations." }),
    (0, import_jsx_runtime4.jsx)(Card, { border: true, padding: 3, children: (0, import_jsx_runtime4.jsxs)(Stack, { space: 4, children: [
      (0, import_jsx_runtime4.jsx)(Text, { size: 1, weight: "semibold", children: translations && translations.length > 0 ? (0, import_jsx_runtime4.jsx)(import_jsx_runtime4.Fragment, { children: "Before this document can be deleted" }) : (0, import_jsx_runtime4.jsx)(import_jsx_runtime4.Fragment, { children: "This document can now be deleted" }) }),
      (0, import_jsx_runtime4.jsx)(DocumentPreview, { value: doc, type: doc._type }),
      translations && translations.length > 0 ? (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
        (0, import_jsx_runtime4.jsx)(Card, { borderTop: true }),
        (0, import_jsx_runtime4.jsxs)(Text, { size: 1, weight: "semibold", children: [
          "The reference in",
          " ",
          translations.length === 1 ? "this translations document" : "these translations documents",
          " ",
          "must be removed"
        ] }),
        translations.map((translation) => (0, import_jsx_runtime4.jsx)(
          DocumentPreview,
          {
            value: translation,
            type: translation._type
          },
          translation._id
        ))
      ] }) : null,
      otherReferences && otherReferences.length > 0 ? (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
        (0, import_jsx_runtime4.jsx)(Card, { borderTop: true }),
        (0, import_jsx_runtime4.jsxs)(Text, { size: 1, weight: "semibold", children: [
          otherReferences.length === 1 ? "There is an additional reference" : "There are additional references",
          " ",
          "to this document"
        ] }),
        otherReferences.map((reference) => (0, import_jsx_runtime4.jsx)(
          DocumentPreview,
          {
            value: reference,
            type: reference._type
          },
          reference._id
        ))
      ] }) : null
    ] }) }),
    otherReferences.length === 0 ? (0, import_jsx_runtime4.jsx)(Text, { children: "This document has no other references." }) : (0, import_jsx_runtime4.jsx)(Text, { children: "You may not be able to delete this document because other documents refer to it." })
  ] });
}
function DeleteTranslationFooter(props) {
  const { translations, onClose, onProceed } = props;
  return (0, import_jsx_runtime4.jsxs)(Grid, { columns: 2, gap: 2, children: [
    (0, import_jsx_runtime4.jsx)(Button, { text: "Cancel", onClick: onClose, mode: "ghost" }),
    (0, import_jsx_runtime4.jsx)(
      Button,
      {
        text: translations && translations.length > 0 ? "Unset translation reference" : "Delete document",
        onClick: onProceed,
        tone: "critical"
      }
    )
  ] });
}
var isPromise2 = (promise) => typeof promise == "object" && typeof promise.then == "function";
var globalCache2 = [];
function shallowEqualArrays2(arrA, arrB, equal2 = (a2, b) => a2 === b) {
  if (arrA === arrB)
    return true;
  if (!arrA || !arrB)
    return false;
  const len = arrA.length;
  if (arrB.length !== len)
    return false;
  for (let i2 = 0; i2 < len; i2++)
    if (!equal2(arrA[i2], arrB[i2]))
      return false;
  return true;
}
function query$1(fn, keys = null, preload3 = false, config2 = {}) {
  keys === null && (keys = [fn]);
  for (const entry2 of globalCache2)
    if (shallowEqualArrays2(keys, entry2.keys, entry2.equal)) {
      if (preload3)
        return;
      if (Object.prototype.hasOwnProperty.call(entry2, "error"))
        throw entry2.error;
      if (Object.prototype.hasOwnProperty.call(entry2, "response"))
        return config2.lifespan && config2.lifespan > 0 && (entry2.timeout && clearTimeout(entry2.timeout), entry2.timeout = setTimeout(entry2.remove, config2.lifespan)), entry2.response;
      if (!preload3)
        throw entry2.promise;
    }
  const entry = {
    keys,
    equal: config2.equal,
    remove: () => {
      const index = globalCache2.indexOf(entry);
      index !== -1 && globalCache2.splice(index, 1);
    },
    promise: (
      // Execute the promise
      (isPromise2(fn) ? fn : fn(...keys)).then((response) => {
        entry.response = response, config2.lifespan && config2.lifespan > 0 && (entry.timeout = setTimeout(entry.remove, config2.lifespan));
      }).catch((error) => entry.error = error)
    )
  };
  if (globalCache2.push(entry), !preload3)
    throw entry.promise;
}
var suspend2 = (fn, keys, config2) => query$1(fn, keys, false, config2);
var __defProp$33 = Object.defineProperty;
var __defProps$22 = Object.defineProperties;
var __getOwnPropDescs$22 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$33 = Object.getOwnPropertySymbols;
var __hasOwnProp$33 = Object.prototype.hasOwnProperty;
var __propIsEnum$33 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$33 = (obj, key, value) => key in obj ? __defProp$33(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$33 = (a2, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$33.call(b, prop) && __defNormalProp$33(a2, prop, b[prop]);
  if (__getOwnPropSymbols$33)
    for (var prop of __getOwnPropSymbols$33(b))
      __propIsEnum$33.call(b, prop) && __defNormalProp$33(a2, prop, b[prop]);
  return a2;
};
var __spreadProps$22 = (a2, b) => __defProps$22(a2, __getOwnPropDescs$22(b));
var DocumentInternationalizationContext = (0, import_react4.createContext)(DEFAULT_CONFIG);
function useDocumentInternationalizationContext() {
  return (0, import_react4.useContext)(DocumentInternationalizationContext);
}
function DocumentInternationalizationProvider(props) {
  const { pluginConfig } = props, client = useClient({ apiVersion: pluginConfig.apiVersion }), workspace = useWorkspace(), supportedLanguages = Array.isArray(pluginConfig.supportedLanguages) ? pluginConfig.supportedLanguages : (
    // eslint-disable-next-line require-await
    suspend2(async () => typeof pluginConfig.supportedLanguages == "function" ? pluginConfig.supportedLanguages(client) : pluginConfig.supportedLanguages, [workspace])
  );
  return (0, import_jsx_runtime4.jsx)(
    DocumentInternationalizationContext.Provider,
    {
      value: __spreadProps$22(__spreadValues$33({}, pluginConfig), { supportedLanguages }),
      children: props.renderDefault(props)
    }
  );
}
var DeleteTranslationAction = (props) => {
  const { id: documentId, published, draft } = props, doc = draft || published, { languageField } = useDocumentInternationalizationContext(), [isDialogOpen, setDialogOpen] = (0, import_react4.useState)(false), [translations, setTranslations] = (0, import_react4.useState)([]), onClose = (0, import_react4.useCallback)(() => setDialogOpen(false), []), documentLanguage = doc ? doc[languageField] : null, toast = useToast(), client = useClient({ apiVersion: API_VERSION }), onProceed = (0, import_react4.useCallback)(() => {
    const tx = client.transaction();
    let operation = "DELETE";
    documentLanguage && translations.length > 0 ? (operation = "UNSET", translations.forEach((translation) => {
      tx.patch(
        translation._id,
        (patch) => patch.unset([
          `${TRANSLATIONS_ARRAY_NAME}[_key == "${documentLanguage}"]`
        ])
      );
    })) : (tx.delete(documentId), tx.delete(`drafts.${documentId}`)), tx.commit().then(() => {
      operation === "DELETE" && onClose(), toast.push({
        status: "success",
        title: operation === "UNSET" ? "Translation reference unset" : "Document deleted",
        description: operation === "UNSET" ? "The document can now be deleted" : null
      });
    }).catch((err) => {
      toast.push({
        status: "error",
        title: operation === "unset" ? "Failed to unset translation reference" : "Failed to delete document",
        description: err.message
      });
    });
  }, [client, documentLanguage, translations, documentId, onClose, toast]);
  return {
    label: "Delete translation...",
    disabled: !doc || !documentLanguage,
    icon: TrashIcon,
    tone: "critical",
    onHandle: () => {
      setDialogOpen(true);
    },
    dialog: isDialogOpen && {
      type: "dialog",
      onClose,
      header: "Delete translation",
      content: doc ? (0, import_jsx_runtime4.jsx)(
        DeleteTranslationDialog,
        {
          doc,
          documentId,
          setTranslations
        }
      ) : null,
      footer: (0, import_jsx_runtime4.jsx)(
        DeleteTranslationFooter,
        {
          onClose,
          onProceed,
          translations
        }
      )
    }
  };
};
var extendStatics = function(d, b) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      Object.prototype.hasOwnProperty.call(b2, p) && (d2[p] = b2[p]);
  }, extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b != "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __values(o2) {
  var s2 = typeof Symbol == "function" && Symbol.iterator, m = s2 && o2[s2], i2 = 0;
  if (m)
    return m.call(o2);
  if (o2 && typeof o2.length == "number")
    return {
      next: function() {
        return o2 && i2 >= o2.length && (o2 = void 0), { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m = typeof Symbol == "function" && o2[Symbol.iterator];
  if (!m)
    return o2;
  var i2 = m.call(o2), r2, ar = [], e2;
  try {
    for (; (n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done; )
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      r2 && !r2.done && (m = i2.return) && m.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++)
      (ar || !(i2 in from)) && (ar || (ar = Array.prototype.slice.call(from, 0, i2)), ar[i2] = from[i2]);
  return to.concat(ar || Array.prototype.slice.call(from));
}
function isFunction(value) {
  return typeof value == "function";
}
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance), instance.stack = new Error().stack;
  }, ctorFunc = createImpl(_super);
  return ctorFunc.prototype = Object.create(Error.prototype), ctorFunc.prototype.constructor = ctorFunc, ctorFunc;
}
var UnsubscriptionError = createErrorClass(function(_super) {
  return function(errors) {
    _super(this), this.message = errors ? errors.length + ` errors occurred during unsubscription:
` + errors.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = errors;
  };
});
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown, this.closed = false, this._parentage = null, this._finalizers = null;
  }
  return Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b, errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage)
        if (this._parentage = null, Array.isArray(_parentage))
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              _parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return) && _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        else
          _parentage.remove(this);
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer))
        try {
          initialFinalizer();
        } catch (e2) {
          errors = e2 instanceof UnsubscriptionError ? e2.errors : [e2];
        }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors != null ? errors : [], err instanceof UnsubscriptionError ? errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors)) : errors.push(err);
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            _finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return) && _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors)
        throw new UnsubscriptionError(errors);
    }
  }, Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this)
      if (this.closed)
        execFinalizer(teardown);
      else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this))
            return;
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
  }, Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  }, Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  }, Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    _parentage === parent ? this._parentage = null : Array.isArray(_parentage) && arrRemove(_parentage, parent);
  }, Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown), teardown instanceof Subscription2 && teardown._removeParent(this);
  }, Subscription2.EMPTY = function() {
    var empty = new Subscription2();
    return empty.closed = true, empty;
  }(), Subscription2;
}();
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  isFunction(finalizer) ? finalizer() : finalizer.unsubscribe();
}
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    for (var args = [], _i = 2; _i < arguments.length; _i++)
      args[_i - 2] = arguments[_i];
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    return clearTimeout(handle);
  },
  delegate: void 0
};
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    throw err;
  });
}
function noop() {
}
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    return _this.isStopped = false, destination ? (_this.destination = destination, isSubscription(destination) && destination.add(_this)) : _this.destination = EMPTY_OBSERVER, _this;
  }
  return Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  }, Subscriber2.prototype.next = function(value) {
    this.isStopped || this._next(value);
  }, Subscriber2.prototype.error = function(err) {
    this.isStopped || (this.isStopped = true, this._error(err));
  }, Subscriber2.prototype.complete = function() {
    this.isStopped || (this.isStopped = true, this._complete());
  }, Subscriber2.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = true, _super.prototype.unsubscribe.call(this), this.destination = null);
  }, Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  }, Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  }, Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  return ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next)
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
  }, ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error)
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    else
      handleUnhandledError(err);
  }, ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete)
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
  }, ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this, partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext)
      partialObserver = {
        next: observerOrNext != null ? observerOrNext : void 0,
        error: error != null ? error : void 0,
        complete: complete != null ? complete : void 0
      };
    else {
      var context_1;
      _this && config.useDeprecatedNextContext ? (context_1 = Object.create(observerOrNext), context_1.unsubscribe = function() {
        return _this.unsubscribe();
      }, partialObserver = {
        next: observerOrNext.next && bind(observerOrNext.next, context_1),
        error: observerOrNext.error && bind(observerOrNext.error, context_1),
        complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
      }) : partialObserver = observerOrNext;
    }
    return _this.destination = new ConsumerObserver(partialObserver), _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  reportUnhandledError(error);
}
function defaultErrorHandler(err) {
  throw err;
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};
function hasLift(source) {
  return isFunction(source == null ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source))
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    return _this.onFinalize = onFinalize, _this.shouldUnsubscribe = shouldUnsubscribe, _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next, _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error, _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete, _this;
  }
  return OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this), !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 || _a.call(this));
    }
  }, OperatorSubscriber2;
}(Subscriber);
var EmptyError = createErrorClass(function(_super) {
  return function() {
    _super(this), this.name = "EmptyError", this.message = "no elements in sequence";
  };
});
function firstValueFrom(source, config2) {
  return new Promise(function(resolve, reject) {
    var subscriber = new SafeSubscriber({
      next: function(value) {
        resolve(value), subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        reject(new EmptyError());
      }
    });
    source.subscribe(subscriber);
  });
}
function filter(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}
var query2 = `*[_type == $translationSchema && $id in translations[].value._ref]{
  _id,
  _createdAt,
  translations
}`;
function useTranslationMetadata(id) {
  const { data, loading, error } = useListeningQuery(query2, {
    params: { id, translationSchema: METADATA_SCHEMA_NAME }
  });
  return { data, loading, error };
}
var documenti18nLocaleNamespace = "document-internationalization";
var documentInternationalizationUsEnglishLocaleBundle = defineLocaleResourceBundle({
  locale: "en-US",
  namespace: documenti18nLocaleNamespace,
  resources: () => import("./resources-DIDH3UZW.js")
});
var DISABLED_REASON_KEY = {
  METADATA_NOT_FOUND: "action.duplicate.disabled.missing-metadata",
  MULTIPLE_METADATA: "action.duplicate.disabled.multiple-metadata",
  NOTHING_TO_DUPLICATE: "action.duplicate.disabled.nothing-to-duplicate",
  NOT_READY: "action.duplicate.disabled.not-ready"
};
var DuplicateWithTranslationsAction = ({
  id,
  type,
  onComplete
}) => {
  const documentStore = useDocumentStore(), { duplicate } = useDocumentOperation(id, type), { navigateIntent } = useRouter(), [isDuplicating, setDuplicating] = (0, import_react4.useState)(false), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "duplicate"
  }), { data, loading: isMetadataDocumentLoading } = useTranslationMetadata(id), hasOneMetadataDocument = (0, import_react4.useMemo)(() => Array.isArray(data) && data.length <= 1, [data]), metadataDocument = Array.isArray(data) && data.length ? data[0] : null, client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), toast = useToast(), { t: s2 } = useTranslation(structureLocaleNamespace), { t: d } = useTranslation(documenti18nLocaleNamespace), currentUser = useCurrentUser(), handle = (0, import_react4.useCallback)(async () => {
    setDuplicating(true);
    try {
      if (!metadataDocument)
        throw new Error("Metadata document not found");
      const translations = /* @__PURE__ */ new Map();
      await Promise.all(
        metadataDocument[TRANSLATIONS_ARRAY_NAME].map(async (translation) => {
          var _a;
          const dupeId2 = v4_default(), locale = translation._key, docId = (_a = translation.value) == null ? void 0 : _a._ref;
          if (!docId)
            throw new Error("Translation document not found");
          const { duplicate: duplicateTranslation } = await firstValueFrom(
            documentStore.pair.editOperations(docId, type).pipe(filter((op) => op.duplicate.disabled !== "NOT_READY"))
          );
          if (duplicateTranslation.disabled)
            throw new Error("Cannot duplicate document");
          const duplicateTranslationSuccess = firstValueFrom(
            documentStore.pair.operationEvents(docId, type).pipe(filter((e2) => e2.op === "duplicate" && e2.type === "success"))
          );
          duplicateTranslation.execute(dupeId2), await duplicateTranslationSuccess, translations.set(locale, dupeId2);
        })
      );
      const { duplicate: duplicateMetadata } = await firstValueFrom(
        documentStore.pair.editOperations(metadataDocument._id, METADATA_SCHEMA_NAME).pipe(filter((op) => op.duplicate.disabled !== "NOT_READY"))
      );
      if (duplicateMetadata.disabled)
        throw new Error("Cannot duplicate document");
      const duplicateMetadataSuccess = firstValueFrom(
        documentStore.pair.operationEvents(metadataDocument._id, METADATA_SCHEMA_NAME).pipe(filter((e2) => e2.op === "duplicate" && e2.type === "success"))
      ), dupeId = v4_default();
      duplicateMetadata.execute(dupeId), await duplicateMetadataSuccess;
      const patch = {
        set: Object.fromEntries(
          Array.from(translations.entries()).map(([locale, documentId]) => [
            `${TRANSLATIONS_ARRAY_NAME}[_key == "${locale}"].value._ref`,
            documentId
          ])
        )
      };
      await client.transaction().patch(dupeId, patch).commit(), navigateIntent("edit", {
        id: Array.from(translations.values()).at(0),
        type
      }), onComplete();
    } catch (error) {
      console.error(error), toast.push({
        status: "error",
        title: "Error duplicating document",
        description: error instanceof Error ? error.message : "Failed to duplicate document"
      });
    } finally {
      setDuplicating(false);
    }
  }, [
    client,
    documentStore.pair,
    metadataDocument,
    navigateIntent,
    onComplete,
    toast,
    type
  ]);
  return (0, import_react4.useMemo)(() => !isPermissionsLoading && !(permissions != null && permissions.granted) ? {
    icon: CopyIcon,
    disabled: true,
    label: d("action.duplicate.label"),
    title: (0, import_jsx_runtime4.jsx)(
      InsufficientPermissionsMessage,
      {
        context: "duplicate-document",
        currentUser
      }
    )
  } : !isMetadataDocumentLoading && !metadataDocument ? {
    icon: CopyIcon,
    disabled: true,
    label: d("action.duplicate.label"),
    title: d(DISABLED_REASON_KEY.METADATA_NOT_FOUND)
  } : hasOneMetadataDocument ? {
    icon: CopyIcon,
    disabled: isDuplicating || !!duplicate.disabled || isPermissionsLoading || isMetadataDocumentLoading,
    label: isDuplicating ? s2("action.duplicate.running.label") : d("action.duplicate.label"),
    title: duplicate.disabled ? s2(DISABLED_REASON_KEY[duplicate.disabled]) : "",
    onHandle: handle
  } : {
    icon: CopyIcon,
    disabled: true,
    label: d("action.duplicate.label"),
    title: d(DISABLED_REASON_KEY.MULTIPLE_METADATA)
  }, [
    currentUser,
    duplicate.disabled,
    handle,
    hasOneMetadataDocument,
    isDuplicating,
    isMetadataDocumentLoading,
    isPermissionsLoading,
    metadataDocument,
    permissions == null ? void 0 : permissions.granted,
    s2,
    d
  ]);
};
DuplicateWithTranslationsAction.action = "duplicate";
DuplicateWithTranslationsAction.displayName = "DuplicateWithTranslationsAction";
function useOpenInNewPane(id, type) {
  const routerContext = (0, import_react4.useContext)(RouterContext), { routerPanesState, groupIndex } = usePaneRouter();
  return (0, import_react4.useCallback)(() => {
    if (!routerContext || !id || !type)
      return;
    if (!routerPanesState.length) {
      routerContext.navigateIntent("edit", { id, type });
      return;
    }
    const panes = [...routerPanesState];
    panes.splice(groupIndex + 1, 0, [
      {
        id,
        params: { type }
      }
    ]);
    const href = routerContext.resolvePathFromState({ panes });
    routerContext.navigateUrl({ path: href });
  }, [id, type, routerContext, routerPanesState, groupIndex]);
}
var __defProp$23 = Object.defineProperty;
var __getOwnPropSymbols$23 = Object.getOwnPropertySymbols;
var __hasOwnProp$23 = Object.prototype.hasOwnProperty;
var __propIsEnum$23 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$23 = (obj, key, value) => key in obj ? __defProp$23(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$23 = (a2, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$23.call(b, prop) && __defNormalProp$23(a2, prop, b[prop]);
  if (__getOwnPropSymbols$23)
    for (var prop of __getOwnPropSymbols$23(b))
      __propIsEnum$23.call(b, prop) && __defNormalProp$23(a2, prop, b[prop]);
  return a2;
};
function createReference(key, ref, type, strengthenOnPublish = true) {
  return {
    _key: key,
    _type: "internationalizedArrayReferenceValue",
    value: __spreadValues$23({
      _type: "reference",
      _ref: ref,
      _weak: true
    }, strengthenOnPublish ? { _strengthenOnPublish: { type } } : {})
  };
}
function LanguageManage(props) {
  const { id, metadataId, schemaType, documentId, sourceLanguageId } = props, open = useOpenInNewPane(id, METADATA_SCHEMA_NAME), openCreated = useOpenInNewPane(metadataId, METADATA_SCHEMA_NAME), { allowCreateMetaDoc, apiVersion, weakReferences } = useDocumentInternationalizationContext(), client = useClient({ apiVersion }), [userHasClicked, setUserHasClicked] = (0, import_react4.useState)(false), canCreate = !id && !!metadataId && allowCreateMetaDoc, handleClick = (0, import_react4.useCallback)(() => {
    if (!id && metadataId && sourceLanguageId) {
      setUserHasClicked(true);
      const transaction = client.transaction(), sourceReference = createReference(
        sourceLanguageId,
        documentId,
        schemaType.name,
        !weakReferences
      ), newMetadataDocument = {
        _id: metadataId,
        _type: METADATA_SCHEMA_NAME,
        schemaTypes: [schemaType.name],
        translations: [sourceReference]
      };
      transaction.createIfNotExists(newMetadataDocument), transaction.commit().then(() => {
        setUserHasClicked(false), openCreated();
      }).catch((err) => {
        console.error(err), setUserHasClicked(false);
      });
    } else
      open();
  }, [
    id,
    metadataId,
    sourceLanguageId,
    client,
    documentId,
    schemaType.name,
    weakReferences,
    openCreated,
    open
  ]);
  return (0, import_jsx_runtime4.jsx)(
    Tooltip,
    {
      animate: true,
      content: (0, import_jsx_runtime4.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime4.jsx)(Text, { muted: true, size: 1, children: "Document has no other translations" }) }),
      fallbackPlacements: ["right", "left"],
      placement: "top",
      portal: true,
      disabled: !!id || canCreate,
      children: (0, import_jsx_runtime4.jsx)(Stack, { children: (0, import_jsx_runtime4.jsx)(
        Button,
        {
          disabled: !id && !canCreate || canCreate && !sourceLanguageId || userHasClicked,
          mode: "ghost",
          text: "Manage Translations",
          icon: CogIcon,
          loading: userHasClicked,
          onClick: handleClick
        }
      ) })
    }
  );
}
function removeExcludedPaths(doc, schemaType) {
  if (!isDocumentSchemaType(schemaType) || !doc)
    return doc;
  const pathsToExclude = extractPaths(doc, schemaType, []).filter(
    (field) => {
      var _a, _b, _c;
      return ((_c = (_b = (_a = field.schemaType) == null ? void 0 : _a.options) == null ? void 0 : _b.documentInternationalization) == null ? void 0 : _c.exclude) === true;
    }
  ).map((field) => pathToString$1(field.path));
  return new Mutation({
    mutations: [
      {
        patch: {
          id: doc._id,
          unset: pathsToExclude
        }
      }
    ]
  }).apply(doc);
}
function extractPaths(doc, schemaType, path) {
  return schemaType.fields.reduce((acc, field) => {
    var _a, _b;
    const fieldPath = [...path, field.name], fieldSchema = field.type, { value } = (_a = extractWithPath(pathToString$1(fieldPath), doc)[0]) != null ? _a : {};
    if (!value)
      return acc;
    const thisFieldWithPath = {
      path: fieldPath,
      name: field.name,
      schemaType: fieldSchema,
      value
    };
    if (fieldSchema.jsonType === "object") {
      const innerFields = extractPaths(doc, fieldSchema, fieldPath);
      return [...acc, thisFieldWithPath, ...innerFields];
    } else if (fieldSchema.jsonType === "array" && fieldSchema.of.length && fieldSchema.of.some((item) => "fields" in item)) {
      const { value: arrayValue } = (_b = extractWithPath(pathToString$1(fieldPath), doc)[0]) != null ? _b : {};
      let arrayPaths = [];
      if (arrayValue != null && arrayValue.length)
        for (const item of arrayValue) {
          const itemPath = [...fieldPath, { _key: item._key }];
          let itemSchema = fieldSchema.of.find((t2) => t2.name === item._type);
          if (item._type || (itemSchema = fieldSchema.of[0]), item._key && itemSchema) {
            const innerFields = extractPaths(
              doc,
              itemSchema,
              itemPath
            ), arrayMember = {
              path: itemPath,
              name: item._key,
              schemaType: itemSchema,
              value: item
            };
            arrayPaths = [...arrayPaths, arrayMember, ...innerFields];
          }
        }
      return [...acc, thisFieldWithPath, ...arrayPaths];
    }
    return [...acc, thisFieldWithPath];
  }, []);
}
var __defProp$12 = Object.defineProperty;
var __defProps$12 = Object.defineProperties;
var __getOwnPropDescs$12 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$12 = Object.getOwnPropertySymbols;
var __hasOwnProp$12 = Object.prototype.hasOwnProperty;
var __propIsEnum$12 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$12 = (obj, key, value) => key in obj ? __defProp$12(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$12 = (a2, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$12.call(b, prop) && __defNormalProp$12(a2, prop, b[prop]);
  if (__getOwnPropSymbols$12)
    for (var prop of __getOwnPropSymbols$12(b))
      __propIsEnum$12.call(b, prop) && __defNormalProp$12(a2, prop, b[prop]);
  return a2;
};
var __spreadProps$12 = (a2, b) => __defProps$12(a2, __getOwnPropDescs$12(b));
function LanguageOption(props) {
  var _a;
  const {
    language,
    schemaType,
    documentId,
    current,
    source,
    sourceLanguageId,
    metadata: metadata2,
    metadataId
  } = props, [userHasClicked, setUserHasClicked] = (0, import_react4.useState)(false), disabled = props.disabled || userHasClicked || current || !source || !sourceLanguageId || !metadataId, translation = metadata2 != null && metadata2.translations.length ? metadata2.translations.find((t2) => t2._key === language.id) : void 0, { apiVersion, languageField, weakReferences, callback } = useDocumentInternationalizationContext(), client = useClient({ apiVersion }), toast = useToast(), open = useOpenInNewPane((_a = translation == null ? void 0 : translation.value) == null ? void 0 : _a._ref, schemaType.name), handleOpen = (0, import_react4.useCallback)(() => open(), [open]);
  (0, import_react4.useEffect)(() => {
    setUserHasClicked(false);
  }, [!!translation]);
  const handleCreate = (0, import_react4.useCallback)(async () => {
    if (!source)
      throw new Error("Cannot create translation without source document");
    if (!sourceLanguageId)
      throw new Error("Cannot create translation without source language ID");
    if (!metadataId)
      throw new Error("Cannot create translation without a metadata ID");
    setUserHasClicked(true);
    const transaction = client.transaction(), newTranslationDocumentId = v4_default();
    let newTranslationDocument = __spreadProps$12(__spreadValues$12({}, source), {
      _id: `drafts.${newTranslationDocumentId}`,
      // 2. Update language of the translation
      [languageField]: language.id
    });
    newTranslationDocument = removeExcludedPaths(
      newTranslationDocument,
      schemaType
    ), transaction.create(newTranslationDocument);
    const sourceReference = createReference(
      sourceLanguageId,
      documentId,
      schemaType.name,
      !weakReferences
    ), newTranslationReference = createReference(
      language.id,
      newTranslationDocumentId,
      schemaType.name,
      !weakReferences
    ), newMetadataDocument = {
      _id: metadataId,
      _type: METADATA_SCHEMA_NAME,
      schemaTypes: [schemaType.name],
      translations: [sourceReference]
    };
    transaction.createIfNotExists(newMetadataDocument);
    const metadataPatch = client.patch(metadataId).setIfMissing({ translations: [sourceReference] }).insert("after", "translations[-1]", [newTranslationReference]);
    transaction.patch(metadataPatch), transaction.commit().then(() => {
      const metadataExisted = !!(metadata2 != null && metadata2._createdAt);
      return callback == null || callback({
        client,
        sourceLanguageId,
        sourceDocument: source,
        newDocument: newTranslationDocument,
        destinationLanguageId: language.id,
        metaDocumentId: metadataId
      }).catch((err) => {
        toast.push({
          status: "error",
          title: "Callback",
          description: `Error while running callback - ${err}.`
        });
      }), toast.push({
        status: "success",
        title: `Created "${language.title}" translation`,
        description: metadataExisted ? "Updated Translations Metadata" : "Created Translations Metadata"
      });
    }).catch((err) => (console.error(err), setUserHasClicked(false), toast.push({
      status: "error",
      title: "Error creating translation",
      description: err.message
    })));
  }, [
    client,
    documentId,
    language.id,
    language.title,
    languageField,
    metadata2 == null ? void 0 : metadata2._createdAt,
    metadataId,
    schemaType,
    source,
    sourceLanguageId,
    toast,
    weakReferences,
    callback
  ]);
  let message;
  return current ? message = "Current document" : translation ? message = `Open ${language.title} translation` : translation || (message = `Create new ${language.title} translation`), (0, import_jsx_runtime4.jsx)(
    Tooltip,
    {
      animate: true,
      content: (0, import_jsx_runtime4.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime4.jsx)(Text, { muted: true, size: 1, children: message }) }),
      fallbackPlacements: ["right", "left"],
      placement: "top",
      portal: true,
      children: (0, import_jsx_runtime4.jsx)(
        Button,
        {
          onClick: translation ? handleOpen : handleCreate,
          mode: current && disabled ? "default" : "bleed",
          disabled,
          children: (0, import_jsx_runtime4.jsxs)(Flex, { gap: 3, align: "center", children: [
            disabled && !current ? (0, import_jsx_runtime4.jsx)(Spinner, {}) : (0, import_jsx_runtime4.jsx)(Text, { size: 2, children: translation ? (0, import_jsx_runtime4.jsx)(SplitVerticalIcon, {}) : current ? (0, import_jsx_runtime4.jsx)(CheckmarkIcon, {}) : (0, import_jsx_runtime4.jsx)(AddIcon, {}) }),
            (0, import_jsx_runtime4.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime4.jsx)(Text, { children: language.title }) }),
            (0, import_jsx_runtime4.jsx)(Badge, { tone: disabled || current ? "default" : "primary", children: language.id })
          ] })
        }
      )
    }
  );
}
function LanguagePatch(props) {
  const { language, source } = props, { apiVersion, languageField } = useDocumentInternationalizationContext(), disabled = props.disabled || !source, client = useClient({ apiVersion }), toast = useToast(), handleClick = (0, import_react4.useCallback)(() => {
    if (!source)
      throw new Error("Cannot patch missing document");
    const currentId = source._id;
    client.patch(currentId).set({ [languageField]: language.id }).commit().then(() => {
      toast.push({
        title: `Set document language to ${language.title}`,
        status: "success"
      });
    }).catch((err) => (console.error(err), toast.push({
      title: `Failed to set document language to ${language.title}`,
      status: "error"
    })));
  }, [source, client, languageField, language, toast]);
  return (0, import_jsx_runtime4.jsx)(
    Button,
    {
      mode: "bleed",
      onClick: handleClick,
      disabled,
      justify: "flex-start",
      children: (0, import_jsx_runtime4.jsxs)(Flex, { gap: 3, align: "center", children: [
        (0, import_jsx_runtime4.jsx)(Text, { size: 2, children: (0, import_jsx_runtime4.jsx)(EditIcon, {}) }),
        (0, import_jsx_runtime4.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime4.jsx)(Text, { children: language.title }) }),
        (0, import_jsx_runtime4.jsx)(Badge, { children: language.id })
      ] })
    }
  );
}
var ConstrainedBox = dt(Box)`
  max-width: 280px;
`;
function Warning({ children }) {
  return (0, import_jsx_runtime4.jsx)(Card, { tone: "caution", padding: 3, children: (0, import_jsx_runtime4.jsx)(Flex, { justify: "center", children: (0, import_jsx_runtime4.jsx)(ConstrainedBox, { children: (0, import_jsx_runtime4.jsx)(Text, { size: 1, align: "center", children }) }) }) });
}
function DocumentInternationalizationMenu(props) {
  const { documentId } = props, schemaType = props.schemaType, { languageField, supportedLanguages } = useDocumentInternationalizationContext(), [query22, setQuery] = (0, import_react4.useState)(""), handleQuery = (0, import_react4.useCallback)((event) => {
    event.currentTarget.value ? setQuery(event.currentTarget.value) : setQuery("");
  }, []), [open, setOpen] = (0, import_react4.useState)(false), handleClick = (0, import_react4.useCallback)(() => setOpen((o2) => !o2), []), [button, setButton] = (0, import_react4.useState)(null), [popover, setPopover] = (0, import_react4.useState)(null), handleClickOutside = (0, import_react4.useCallback)(() => setOpen(false), []);
  useClickOutside(handleClickOutside, [button, popover]);
  const { data, loading, error } = useTranslationMetadata(documentId), metadata2 = Array.isArray(data) && data.length ? data[0] : null, metadataId = (0, import_react4.useMemo)(() => {
    var _a;
    return loading ? null : (_a = metadata2 == null ? void 0 : metadata2._id) != null ? _a : v4_default();
  }, [loading, metadata2 == null ? void 0 : metadata2._id]), { draft, published } = useEditState(documentId, schemaType.name), source = draft || published, documentIsInOneMetadataDocument = (0, import_react4.useMemo)(() => Array.isArray(data) && data.length <= 1, [data]), sourceLanguageId = source == null ? void 0 : source[languageField], sourceLanguageIsValid = supportedLanguages.some(
    (l2) => l2.id === sourceLanguageId
  ), allLanguagesAreValid = (0, import_react4.useMemo)(() => {
    const valid = supportedLanguages.every((l2) => l2.id && l2.title);
    return valid || console.warn(
      'Not all languages are valid. It should be an array of objects with an "id" and "title" property. Or a function that returns an array of objects with an "id" and "title" property.',
      supportedLanguages
    ), valid;
  }, [supportedLanguages]), content = (0, import_jsx_runtime4.jsx)(Box, { padding: 1, children: error ? (0, import_jsx_runtime4.jsx)(Card, { tone: "critical", padding: 1, children: (0, import_jsx_runtime4.jsx)(Text, { children: "There was an error returning translations metadata" }) }) : (0, import_jsx_runtime4.jsxs)(Stack, { space: 1, children: [
    (0, import_jsx_runtime4.jsx)(
      LanguageManage,
      {
        id: metadata2 == null ? void 0 : metadata2._id,
        documentId,
        metadataId,
        schemaType,
        sourceLanguageId
      }
    ),
    supportedLanguages.length > 4 ? (0, import_jsx_runtime4.jsx)(
      TextInput,
      {
        onChange: handleQuery,
        value: query22,
        placeholder: "Filter languages"
      }
    ) : null,
    supportedLanguages.length > 0 ? (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
      loading ? null : (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
        data && documentIsInOneMetadataDocument ? null : (0, import_jsx_runtime4.jsx)(Warning, { children: "This document has been found in more than one Translations Metadata documents" }),
        allLanguagesAreValid ? null : (0, import_jsx_runtime4.jsx)(Warning, { children: "Not all language objects are valid. See the console." }),
        sourceLanguageId ? null : (0, import_jsx_runtime4.jsxs)(Warning, { children: [
          "Choose a language to apply to",
          " ",
          (0, import_jsx_runtime4.jsx)("strong", { children: "this Document" })
        ] }),
        sourceLanguageId && !sourceLanguageIsValid ? (0, import_jsx_runtime4.jsxs)(Warning, { children: [
          "Select a supported language. Current language value:",
          " ",
          (0, import_jsx_runtime4.jsx)("code", { children: sourceLanguageId })
        ] }) : null
      ] }),
      supportedLanguages.filter((language) => query22 ? language.title.toLowerCase().includes(query22.toLowerCase()) : true).map(
        (language) => {
          var _a;
          return !loading && sourceLanguageId && sourceLanguageIsValid ? (
            // Button to duplicate this document to a new translation
            // And either create or update the metadata document
            (0, import_jsx_runtime4.jsx)(
              LanguageOption,
              {
                language,
                schemaType,
                documentId,
                disabled: loading || !allLanguagesAreValid,
                current: language.id === sourceLanguageId,
                metadata: metadata2,
                metadataId,
                source,
                sourceLanguageId
              },
              language.id
            )
          ) : (
            // Button to set a language field on *this* document
            (0, import_jsx_runtime4.jsx)(
              LanguagePatch,
              {
                source,
                language,
                disabled: (_a = loading || !allLanguagesAreValid || (metadata2 == null ? void 0 : metadata2.translations.filter((t2) => {
                  var _a2;
                  return ((_a2 = t2 == null ? void 0 : t2.value) == null ? void 0 : _a2._ref) !== documentId;
                }).some((t2) => t2._key === language.id))) != null ? _a : false
              },
              language.id
            )
          );
        }
      )
    ] }) : null
  ] }) }), issueWithTranslations = !loading && sourceLanguageId && !sourceLanguageIsValid;
  return !documentId || !schemaType || !schemaType.name ? null : (0, import_jsx_runtime4.jsx)(
    Popover,
    {
      animate: true,
      constrainSize: true,
      content,
      open,
      portal: true,
      ref: setPopover,
      overflow: "auto",
      tone: "default",
      children: (0, import_jsx_runtime4.jsx)(
        Button,
        {
          text: "Translations",
          mode: "bleed",
          disabled: !source,
          tone: !source || loading || !issueWithTranslations ? void 0 : "caution",
          icon: TranslateIcon,
          onClick: handleClick,
          ref: setButton,
          selected: open
        }
      )
    }
  );
}
var DeleteMetadataAction = (props) => {
  const { id: documentId, published, draft, onComplete } = props, doc = draft || published, [isDialogOpen, setDialogOpen] = (0, import_react4.useState)(false), onClose = (0, import_react4.useCallback)(() => setDialogOpen(false), []), translations = (0, import_react4.useMemo)(
    () => doc && Array.isArray(doc[TRANSLATIONS_ARRAY_NAME]) ? doc[TRANSLATIONS_ARRAY_NAME] : [],
    [doc]
  ), toast = useToast(), client = useClient({ apiVersion: API_VERSION }), onProceed = (0, import_react4.useCallback)(() => {
    const tx = client.transaction();
    tx.patch(documentId, (patch) => patch.unset([TRANSLATIONS_ARRAY_NAME])), translations.length > 0 && translations.forEach((translation) => {
      tx.delete(translation.value._ref), tx.delete(`drafts.${translation.value._ref}`);
    }), tx.delete(documentId), tx.delete(`drafts.${documentId}`), tx.commit().then(() => {
      onClose(), toast.push({
        status: "success",
        title: "Deleted document and translations"
      });
    }).catch((err) => {
      toast.push({
        status: "error",
        title: "Failed to delete document and translations",
        description: err.message
      });
    });
  }, [client, translations, documentId, onClose, toast]);
  return {
    label: "Delete all translations",
    disabled: !doc || !translations.length,
    icon: TrashIcon,
    tone: "critical",
    onHandle: () => {
      setDialogOpen(true);
    },
    dialog: isDialogOpen && {
      type: "confirm",
      onCancel: onComplete,
      onConfirm: () => {
        onProceed(), onComplete();
      },
      tone: "critical",
      message: translations.length === 1 ? "Delete 1 translation and this document" : `Delete all ${translations.length} translations and this document`
    }
  };
};
function LanguageBadge(props) {
  var _a, _b;
  const source = (props == null ? void 0 : props.draft) || (props == null ? void 0 : props.published), { languageField, supportedLanguages } = useDocumentInternationalizationContext(), languageId = source == null ? void 0 : source[languageField];
  if (!languageId)
    return null;
  const language = Array.isArray(supportedLanguages) ? supportedLanguages.find((l2) => l2.id === languageId) : null;
  return {
    label: (_a = language == null ? void 0 : language.id) != null ? _a : String(languageId),
    title: (_b = language == null ? void 0 : language.title) != null ? _b : void 0,
    color: "primary"
  };
}
function DocumentCheck(props) {
  const {
    id,
    onCheckComplete,
    addInvalidId,
    removeInvalidId,
    addDraftId,
    removeDraftId
  } = props, editState = useEditState(id, ""), { isValidating, validation } = useValidationStatus(id, ""), schema = useSchema(), validationHasErrors = (0, import_react4.useMemo)(() => !isValidating && validation.length > 0 && validation.some((item) => item.level === "error"), [isValidating, validation]);
  if ((0, import_react4.useEffect)(() => {
    validationHasErrors ? addInvalidId(id) : removeInvalidId(id), editState.draft ? addDraftId(id) : removeDraftId(id), isValidating || onCheckComplete(id);
  }, [
    addDraftId,
    addInvalidId,
    editState.draft,
    id,
    isValidating,
    onCheckComplete,
    removeDraftId,
    removeInvalidId,
    validationHasErrors
  ]), !editState.draft)
    return null;
  const schemaType = schema.get(editState.draft._type);
  return (0, import_jsx_runtime4.jsx)(
    Card,
    {
      border: true,
      padding: 2,
      tone: validationHasErrors ? "critical" : "positive",
      children: editState.draft && schemaType ? (0, import_jsx_runtime4.jsx)(
        Preview$1,
        {
          layout: "default",
          value: editState.draft,
          schemaType
        }
      ) : (0, import_jsx_runtime4.jsx)(Spinner, {})
    }
  );
}
function InfoIcon(props) {
  const { text, icon, tone, children } = props;
  return (0, import_jsx_runtime4.jsx)(
    Tooltip,
    {
      animate: true,
      portal: true,
      content: children ? (0, import_jsx_runtime4.jsx)(import_jsx_runtime4.Fragment, { children }) : (0, import_jsx_runtime4.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime4.jsx)(Text, { size: 1, children: text }) }),
      children: (0, import_jsx_runtime4.jsx)(TextWithTone, { tone, size: 1, children: (0, import_jsx_runtime4.jsx)(icon, {}) })
    }
  );
}
function Info() {
  return (0, import_jsx_runtime4.jsx)(InfoIcon, { icon: InfoOutlineIcon, tone: "primary", children: (0, import_jsx_runtime4.jsxs)(Stack, { padding: 3, space: 4, style: { maxWidth: 250 }, children: [
    (0, import_jsx_runtime4.jsx)(Box, { children: (0, import_jsx_runtime4.jsx)(Text, { size: 1, children: "Bulk publishing uses the Scheduling API." }) }),
    (0, import_jsx_runtime4.jsx)(Box, { children: (0, import_jsx_runtime4.jsx)(Text, { size: 1, children: "Customized Document Actions in the Studio will not execute. Webhooks will execute." }) }),
    (0, import_jsx_runtime4.jsx)(Box, { children: (0, import_jsx_runtime4.jsx)(Text, { size: 1, children: "Validation is checked before rendering the button below, but the Scheduling API will not check for  or enforce  validation." }) })
  ] }) });
}
function BulkPublish(props) {
  const { translations } = props, client = useClient({ apiVersion: API_VERSION }), { projectId, dataset } = useWorkspace(), toast = useToast(), [invalidIds, setInvalidIds] = (0, import_react4.useState)(null), [checkedIds, setCheckedIds] = (0, import_react4.useState)([]), onCheckComplete = (0, import_react4.useCallback)((id) => {
    setCheckedIds((ids) => Array.from(/* @__PURE__ */ new Set([...ids, id])));
  }, []), [open, setOpen] = (0, import_react4.useState)(false), onOpen = (0, import_react4.useCallback)(() => setOpen(true), []), onClose = (0, import_react4.useCallback)(() => setOpen(false), []), addInvalidId = (0, import_react4.useCallback)((id) => {
    setInvalidIds((ids) => ids ? Array.from(/* @__PURE__ */ new Set([...ids, id])) : [id]);
  }, []), removeInvalidId = (0, import_react4.useCallback)((id) => {
    setInvalidIds((ids) => ids ? ids.filter((i2) => i2 !== id) : []);
  }, []), [draftIds, setDraftIds] = (0, import_react4.useState)([]), addDraftId = (0, import_react4.useCallback)((id) => {
    setDraftIds((ids) => Array.from(/* @__PURE__ */ new Set([...ids, id])));
  }, []), removeDraftId = (0, import_react4.useCallback)((id) => {
    setDraftIds((ids) => ids.filter((i2) => i2 !== id));
  }, []), handleBulkPublish = (0, import_react4.useCallback)(() => {
    const body = translations.map((translation) => ({
      documentId: translation.value._ref
    }));
    client.request({
      uri: `/publish/${projectId}/${dataset}`,
      method: "POST",
      body
    }).then(() => {
      toast.push({
        status: "success",
        title: "Success",
        description: "Bulk publish complete"
      });
    }).catch((err) => {
      console.error(err), toast.push({
        status: "error",
        title: "Error",
        description: "Bulk publish failed"
      });
    });
  }, [translations, client, projectId, dataset, toast]), disabled = (
    // Not all documents have been checked
    checkedIds.length !== translations.length || // Some document(s) are invalid
    !!(invalidIds && (invalidIds == null ? void 0 : invalidIds.length) > 0) || // No documents are drafts
    !draftIds.length
  );
  return (translations == null ? void 0 : translations.length) > 0 ? (0, import_jsx_runtime4.jsx)(Card, { padding: 4, border: true, radius: 2, children: (0, import_jsx_runtime4.jsxs)(Stack, { space: 3, children: [
    (0, import_jsx_runtime4.jsxs)(Inline, { space: 3, children: [
      (0, import_jsx_runtime4.jsx)(Text, { weight: "bold", size: 1, children: "Bulk publishing" }),
      (0, import_jsx_runtime4.jsx)(Info, {})
    ] }),
    (0, import_jsx_runtime4.jsx)(Stack, { children: (0, import_jsx_runtime4.jsx)(
      Button,
      {
        onClick: onOpen,
        text: "Prepare bulk publishing",
        mode: "ghost"
      }
    ) }),
    open && (0, import_jsx_runtime4.jsx)(
      Dialog,
      {
        animate: true,
        header: "Bulk publishing",
        id: "bulk-publish-dialog",
        onClose,
        zOffset: 1e3,
        width: 3,
        children: (0, import_jsx_runtime4.jsxs)(Stack, { space: 4, padding: 4, children: [
          draftIds.length > 0 ? (0, import_jsx_runtime4.jsxs)(Stack, { space: 2, children: [
            (0, import_jsx_runtime4.jsxs)(Text, { size: 1, children: [
              "There",
              " ",
              draftIds.length === 1 ? "is 1 draft document" : `are ${draftIds.length} draft documents`,
              "."
            ] }),
            invalidIds && invalidIds.length > 0 ? (0, import_jsx_runtime4.jsxs)(TextWithTone, { tone: "critical", size: 1, children: [
              invalidIds && invalidIds.length === 1 ? "1 draft document has" : `${invalidIds && invalidIds.length} draft documents have`,
              " ",
              "validation issues that must addressed first"
            ] }) : (0, import_jsx_runtime4.jsx)(TextWithTone, { tone: "positive", size: 1, children: "All drafts are valid and can be bulk published" })
          ] }) : null,
          (0, import_jsx_runtime4.jsx)(Stack, { space: 1, children: translations.filter((translation) => {
            var _a;
            return (_a = translation == null ? void 0 : translation.value) == null ? void 0 : _a._ref;
          }).map((translation) => (0, import_jsx_runtime4.jsx)(
            DocumentCheck,
            {
              id: translation.value._ref,
              onCheckComplete,
              addInvalidId,
              removeInvalidId,
              addDraftId,
              removeDraftId
            },
            translation._key
          )) }),
          draftIds.length > 0 ? (0, import_jsx_runtime4.jsx)(
            Button,
            {
              mode: "ghost",
              tone: invalidIds && (invalidIds == null ? void 0 : invalidIds.length) > 0 ? "caution" : "positive",
              text: draftIds.length === 1 ? "Publish draft document" : `Bulk publish ${draftIds.length} draft documents`,
              onClick: handleBulkPublish,
              disabled
            }
          ) : (0, import_jsx_runtime4.jsx)(Text, { muted: true, size: 1, children: "No draft documents to publish" })
        ] })
      }
    )
  ] }) }) : null;
}
function ReferencePatcher(props) {
  const { translation, documentType, metadataId } = props, editState = useEditState(translation.value._ref, documentType), client = useClient({ apiVersion: API_VERSION }), { onChange } = useDocumentPane();
  return (0, import_react4.useEffect)(() => {
    if (
      // We have a reference
      translation.value._ref && // It's still weak and not-yet-strengthened
      translation.value._weak && // We also want to keep this check because maybe the user *configured* weak refs
      translation.value._strengthenOnPublish && // The referenced document has just been published
      !editState.draft && editState.published && editState.ready
    ) {
      const referencePathBase = [
        "translations",
        { _key: translation._key },
        "value"
      ];
      onChange(
        new PatchEvent([
          unset([...referencePathBase, "_weak"]),
          unset([...referencePathBase, "_strengthenOnPublish"])
        ])
      );
    }
  }, [translation, editState, metadataId, client, onChange]), null;
}
function OptimisticallyStrengthen(props) {
  const { translations = [], metadataId } = props;
  return translations.length ? (0, import_jsx_runtime4.jsx)(import_jsx_runtime4.Fragment, { children: translations.map(
    (translation) => {
      var _a;
      return (_a = translation.value._strengthenOnPublish) != null && _a.type ? (0, import_jsx_runtime4.jsx)(
        ReferencePatcher,
        {
          translation,
          documentType: translation.value._strengthenOnPublish.type,
          metadataId
        },
        translation._key
      ) : null;
    }
  ) }) : null;
}
var metadata = (schemaTypes, metadataFields) => defineType({
  type: "document",
  name: METADATA_SCHEMA_NAME,
  title: "Translation metadata",
  icon: TranslateIcon,
  liveEdit: true,
  fields: [
    defineField({
      name: TRANSLATIONS_ARRAY_NAME,
      type: "internationalizedArrayReference"
    }),
    defineField({
      name: "schemaTypes",
      description: "Optional: Used to filter the reference fields above so all translations share the same types.",
      type: "array",
      of: [{ type: "string" }],
      options: { list: schemaTypes },
      readOnly: ({ value }) => !!value
    }),
    ...metadataFields
  ],
  preview: {
    select: {
      translations: TRANSLATIONS_ARRAY_NAME,
      documentSchemaTypes: "schemaTypes"
    },
    prepare(selection) {
      const { translations = [], documentSchemaTypes = [] } = selection, title = translations.length === 1 ? "1 Translation" : `${translations.length} Translations`, languageKeys = translations.length ? translations.map((t2) => t2._key.toUpperCase()).join(", ") : "", subtitle = [
        languageKeys ? `(${languageKeys})` : null,
        documentSchemaTypes != null && documentSchemaTypes.length ? documentSchemaTypes.map((s2) => s2).join(", ") : ""
      ].filter(Boolean).join(" ");
      return {
        title,
        subtitle
      };
    }
  }
});
var __defProp2 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a2, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp2.call(b, prop) && __defNormalProp2(a2, prop, b[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b))
      __propIsEnum2.call(b, prop) && __defNormalProp2(a2, prop, b[prop]);
  return a2;
};
var __spreadProps2 = (a2, b) => __defProps2(a2, __getOwnPropDescs2(b));
var documentInternationalization = definePlugin(
  (config2) => {
    const pluginConfig = __spreadValues2(__spreadValues2({}, DEFAULT_CONFIG), config2), {
      supportedLanguages,
      schemaTypes,
      languageField,
      bulkPublish,
      metadataFields
    } = pluginConfig;
    if (schemaTypes.length === 0)
      throw new Error(
        "You must specify at least one schema type on which to enable document internationalization. Update the `schemaTypes` option in the documentInternationalization() configuration."
      );
    return {
      name: "@sanity/document-internationalization",
      studio: {
        components: {
          layout: (props) => DocumentInternationalizationProvider(__spreadProps2(__spreadValues2({}, props), { pluginConfig }))
        }
      },
      i18n: {
        bundles: [documentInternationalizationUsEnglishLocaleBundle]
      },
      // Adds:
      // - A bulk-publishing UI component to the form
      // - Will only work for projects on a compatible plan
      form: {
        components: {
          input: (props) => {
            var _a, _b, _c;
            if (props.id === "root" && props.schemaType.name === METADATA_SCHEMA_NAME && isSanityDocument(props == null ? void 0 : props.value)) {
              const metadataId = (_a = props == null ? void 0 : props.value) == null ? void 0 : _a._id, translations = (_c = (_b = props == null ? void 0 : props.value) == null ? void 0 : _b.translations) != null ? _c : [], weakAndTypedTranslations = translations.filter(
                ({ value }) => (value == null ? void 0 : value._weak) && value._strengthenOnPublish
              );
              return (0, import_jsx_runtime4.jsxs)(Stack, { space: 5, children: [
                bulkPublish ? (0, import_jsx_runtime4.jsx)(BulkPublish, { translations }) : null,
                weakAndTypedTranslations.length > 0 ? (0, import_jsx_runtime4.jsx)(
                  OptimisticallyStrengthen,
                  {
                    metadataId,
                    translations: weakAndTypedTranslations
                  }
                ) : null,
                props.renderDefault(props)
              ] });
            }
            return props.renderDefault(props);
          }
        }
      },
      // Adds:
      // - The `Translations` dropdown to the editing form
      // - `Badges` to documents with a language value
      // - The `DeleteMetadataAction` action to the metadata document type
      document: {
        unstable_languageFilter: (prev, ctx) => {
          const { schemaType, documentId } = ctx;
          return schemaTypes.includes(schemaType) && documentId ? [
            ...prev,
            (props) => DocumentInternationalizationMenu(__spreadProps2(__spreadValues2({}, props), { documentId }))
          ] : prev;
        },
        badges: (prev, { schemaType }) => schemaTypes.includes(schemaType) ? [(props) => LanguageBadge(props), ...prev] : prev,
        actions: (prev, { schemaType }) => schemaType === METADATA_SCHEMA_NAME ? [...prev, DeleteMetadataAction] : prev
      },
      // Adds:
      // - The `Translations metadata` document type to the schema
      schema: {
        // Create the metadata document type
        types: [metadata(schemaTypes, metadataFields)],
        // For every schema type this plugin is enabled on
        // Create an initial value template to set the language
        templates: (prev, { schema }) => {
          if (!Array.isArray(supportedLanguages))
            return prev;
          const parameterizedTemplates = schemaTypes.map((schemaType) => {
            var _a, _b;
            return {
              id: `${schemaType}-parameterized`,
              title: `${(_b = (_a = schema == null ? void 0 : schema.get(schemaType)) == null ? void 0 : _a.title) != null ? _b : schemaType}: with Language`,
              schemaType,
              parameters: [
                { name: "languageId", title: "Language ID", type: "string" }
              ],
              value: ({ languageId }) => ({
                [languageField]: languageId
              })
            };
          }), staticTemplates = schemaTypes.flatMap((schemaType) => supportedLanguages.map((language) => {
            var _a, _b;
            return {
              id: `${schemaType}-${language.id}`,
              title: `${language.title} ${(_b = (_a = schema == null ? void 0 : schema.get(schemaType)) == null ? void 0 : _a.title) != null ? _b : schemaType}`,
              schemaType,
              value: {
                [languageField]: language.id
              }
            };
          }));
          return [...prev, ...parameterizedTemplates, ...staticTemplates];
        }
      },
      // Uses:
      // - `sanity-plugin-internationalized-array` to maintain the translations array
      plugins: [
        // Translation metadata stores its references using this plugin
        // It cuts down on attribute usage and gives UI conveniences to add new translations
        internationalizedArray({
          languages: supportedLanguages,
          fieldTypes: [
            defineField(
              {
                name: "reference",
                type: "reference",
                to: schemaTypes.map((type) => ({ type })),
                weak: pluginConfig.weakReferences,
                // Reference filters don't actually enforce validation!
                validation: (Rule) => (
                  // @ts-expect-error - fix typings
                  Rule.custom(async (item, context) => {
                    var _a;
                    if (!((_a = item == null ? void 0 : item.value) != null && _a._ref) || !(item != null && item._key))
                      return true;
                    const valueLanguage = await context.getClient({ apiVersion: API_VERSION }).fetch(
                      `*[_id in [$ref, $draftRef]][0].${languageField}`,
                      {
                        ref: item.value._ref,
                        draftRef: `drafts.${item.value._ref}`
                      }
                    );
                    return valueLanguage && valueLanguage === item._key ? true : "Referenced document does not have the correct language value";
                  })
                ),
                options: {
                  // @ts-expect-error - Update type once it knows the values of this filter
                  filter: ({ parent, document }) => {
                    if (!parent)
                      return null;
                    const language = (Array.isArray(parent) ? parent : [parent]).find((p) => p._key);
                    return language != null && language._key ? document.schemaTypes ? {
                      filter: `_type in $schemaTypes && ${languageField} == $language`,
                      params: {
                        schemaTypes: document.schemaTypes,
                        language: language._key
                      }
                    } : {
                      filter: `${languageField} == $language`,
                      params: { language: language._key }
                    } : null;
                  }
                }
              },
              { strict: false }
            )
          ]
        })
      ]
    };
  }
);
export {
  DeleteTranslationAction,
  DocumentInternationalizationMenu,
  DuplicateWithTranslationsAction,
  documentInternationalization,
  useDocumentInternationalizationContext
};
//# sourceMappingURL=@sanity_document-internationalization.js.map
